"""
YAML to Python Converter for Civ7 Modding Tools

Converts a YAML configuration file into a Python script that uses the
civ7_modding_tools library to create a civilization mod.

Usage:
    python yml_to_py.py babylon_civilization.yml -o babylon_generated.py
"""

import argparse
import sys
from pathlib import Path
from typing import Any

import yaml


class YamlToPyConverter:
    """Converts YAML mod configuration to Python code."""
    
    def __init__(self, yaml_data: dict[str, Any]):
        """Initialize converter with parsed YAML data."""
        self.data = yaml_data
        self.lines: list[str] = []
        self.indent_level = 0
        self.action_group_var_name: str = 'ALWAYS'  # Default action group variable
        
        # Preprocess data to normalize wizard format to standard YAML format
        self._ensure_progression_tree_nodes()
        
        # Auto-create TraditionBuilders for any traditions referenced in progression tree node unlocks
        self._ensure_tradition_builders()
    
    def _ensure_progression_tree_nodes(self) -> None:
        """
        Ensure all progression trees have valid node bindings.
        
        This preprocessing step:
        - Generates default nodes for any tree that has no nodes
        - Ensures all nodes have 'id' fields for conversion
        - Transforms wizard-format nodes to standard YAML format
        - Builds prereqs from prereq_node_indices (wizard UI format)
        
        This prevents build errors when progression trees exist but have no nodes defined.
        """
        existing_trees = self.data.get('progression_trees', [])
        existing_nodes = self.data.get('progression_tree_nodes', [])
        
        # Transform wizard-format nodes to standard format
        for idx, node in enumerate(existing_nodes):
            # Ensure node has 'id' field
            if 'id' not in node:
                node_type = node.get('progression_tree_node_type', f'node_{idx}')
                node_id = node_type.replace('NODE_', '').lower()
                node['id'] = node_id
        
        existing_node_ids = {node['id'] for node in existing_nodes if 'id' in node}
        
        # Identify placeholder nodes (auto-generated by generateDefaultProgressionTree)
        placeholder_node_ids = set()
        for node in existing_nodes:
            node_id = node.get('id', '')
            # Placeholder nodes have simple names and minimal data
            localizations = node.get('localizations', [{}])
            if localizations and isinstance(localizations, list):
                name = localizations[0].get('name', '')
                # If name contains "Foundations" or "Advancement" and has no description, it's likely a placeholder
                if ('Foundations' in name or 'Advancement' in name) and not localizations[0].get('description'):
                    placeholder_node_ids.add(node_id)
        
        # Identify real nodes (wizard-created nodes with actual content)
        real_node_ids = existing_node_ids - placeholder_node_ids
        
        # Process trees to handle prereq_node_indices at tree level and bind real nodes
        for tree in existing_trees:
            tree_bindings = tree.get('bindings', [])
            
            # If tree has only placeholder bindings but real nodes exist, replace bindings with real nodes
            if real_node_ids and all(
                binding in placeholder_node_ids
                for binding in tree_bindings
                if binding in existing_node_ids
            ):
                # Update tree to bind to real nodes instead of placeholders
                tree['bindings'] = list(real_node_ids)
                tree_bindings = tree['bindings']
            
            # Check if ANY node bound to this tree has prereq_node_indices
            # If so, we rebuild prereqs entirely from the indices (they are the source of truth)
            has_prereq_indices = False
            for node in existing_nodes:
                if node.get('id') in tree_bindings:
                    if 'prereq_node_indices' in node and isinstance(node.get('prereq_node_indices'), list):
                        has_prereq_indices = True
                        break
            
            if has_prereq_indices:
                # REPLACE all prereqs - rebuild from prereq_node_indices
                tree['progression_tree_prereqs'] = []
                
                for node in existing_nodes:
                    node_id = node.get('id')
                    if node_id not in tree_bindings:
                        continue
                    
                    prereq_indices = node.get('prereq_node_indices', [])
                    if not prereq_indices:
                        continue
                    
                    current_node_type = node.get('progression_tree_node_type')
                    
                    for prereq_idx in prereq_indices:
                        if prereq_idx < len(existing_nodes):
                            prereq_node = existing_nodes[prereq_idx]
                            prereq_node_type = prereq_node.get('progression_tree_node_type')
                            
                            prereq_entry = {
                                'node': current_node_type,
                                'prereq_node': prereq_node_type
                            }
                            if prereq_entry not in tree['progression_tree_prereqs']:
                                tree['progression_tree_prereqs'].append(prereq_entry)
            
            # Check if tree has valid node bindings
            has_valid_nodes = any(binding_id in existing_node_ids for binding_id in tree_bindings)
            
            if not tree_bindings or not has_valid_nodes:
                # Tree has no valid nodes - generate defaults
                tree_id = tree.get('id', 'progression_tree')
                tree_type = tree.get('progression_tree_type', 'TREE_CIVICS_CUSTOM')
                civ_name = self.data.get('civilization', {}).get('localizations', [{}])[0].get('name', 'Custom')
                
                node1_type = f"{tree_type.replace('TREE_', 'NODE_')}_1"
                node2_type = f"{tree_type.replace('TREE_', 'NODE_')}_2"
                node1_id = f"{tree_id}_node1"
                node2_id = f"{tree_id}_node2"
                
                # Initialize nodes array if needed
                if 'progression_tree_nodes' not in self.data:
                    self.data['progression_tree_nodes'] = []
                
                # Add default nodes
                self.data['progression_tree_nodes'].append({
                    'id': node1_id,
                    'progression_tree_node_type': node1_type,
                    'progression_tree_node': {
                        'progression_tree_node_type': node1_type,
                    },
                    'localizations': [{'name': f'{civ_name} Foundations'}],
                    'bindings': [],
                })
                
                self.data['progression_tree_nodes'].append({
                    'id': node2_id,
                    'progression_tree_node_type': node2_type,
                    'progression_tree_node': {
                        'progression_tree_node_type': node2_type,
                    },
                    'localizations': [{'name': f'{civ_name} Advancement'}],
                    'bindings': [],
                })
                
                # Update tree bindings
                tree['bindings'] = [node1_id, node2_id]
                
                # Ensure prereqs exist
                if 'progression_tree_prereqs' not in tree:
                    tree['progression_tree_prereqs'] = []
                tree['progression_tree_prereqs'].append({
                    'node': node2_type,
                    'prereq_node': node1_type,
                })
    
    def _ensure_tradition_builders(self) -> None:
        """
        Ensure TraditionBuilder instances exist for any traditions referenced in progression tree node unlocks.
        This allows inline tradition unlocks without requiring separate tradition definitions.
        
        Also converts wizard-format traditions (with is_existing_tradition: false) to builder format.
        If a tradition is marked as is_existing_tradition: true, a civ-specific copy is created
        with a _{CIV_NAME} suffix and the same base modifiers as the original tradition.
        
        Skips traditions that:
        - Already have builder definitions (with 'id' field that looks like 'tradition_builder_*')
        - Are marked as is_existing_tradition: true (base game traditions being reused)
        """
        existing_nodes = self.data.get('progression_tree_nodes', [])
        existing_traditions = self.data.get('traditions', [])

        civ_type = self.data.get('civilization', {}).get('civilization_type', '')
        civ_suffix = civ_type.replace('CIVILIZATION_', '') if civ_type else 'CUSTOM'

        # Load base game tradition metadata for cloning existing traditions
        try:
            from civ7_modding_tools.data import get_traditions
            base_traditions = {
                t.get('id'): t
                for t in get_traditions()
                if isinstance(t, dict) and t.get('id')
            }
        except Exception:
            base_traditions = {}
        
        # First, convert wizard-format traditions to builder format
        traditions_to_convert = []
        for idx, t in enumerate(existing_traditions):
            # Check if this is a wizard-format tradition that needs conversion
            tradition_id = t.get('id')
            is_existing = t.get('is_existing_tradition', False)
            
            # If it has an 'id' that's not a builder ID pattern and is not an existing tradition, convert it
            if tradition_id and not tradition_id.startswith('tradition_builder_') and not is_existing:
                traditions_to_convert.append((idx, t, tradition_id))
        
        # Convert wizard traditions to builder format
        builder_counter = 1
        existing_builder_ids = {t.get('id') for t in existing_traditions if t.get('id', '').startswith('tradition_builder_')}
        
        for idx, wizard_tradition, tradition_type in traditions_to_convert:
            # Generate unique builder ID
            while f'tradition_builder_{builder_counter}' in existing_builder_ids:
                builder_counter += 1
            builder_id = f'tradition_builder_{builder_counter}'
            builder_counter += 1
            
            # Extract age and trait from wizard format
            age = wizard_tradition.get('age', '') or 'AGE_ANTIQUITY'
            trait_type = wizard_tradition.get('trait_type', '')
            
            # If no trait specified, infer from civilization
            if not trait_type:
                civ_data = self.data.get('civilization', {})
                civ_type = civ_data.get('civilization_type', '')
                if civ_type:
                    civ_name = civ_type.replace('CIVILIZATION_', '')
                    trait_type = f'TRAIT_{civ_name}'
            
            # Create builder-format entry
            builder_entry = {
                'id': builder_id,
                'tradition_type': tradition_type,
                'tradition': {
                    'age_type': age,
                    'trait_type': trait_type,
                },
                'localizations': wizard_tradition.get('localizations', []),
            }
            
            # Add modifier_ids if present
            if 'modifier_ids' in wizard_tradition:
                builder_entry['bindings'] = wizard_tradition['modifier_ids']
            
            # Replace wizard entry with builder entry
            existing_traditions[idx] = builder_entry
            existing_builder_ids.add(builder_id)

        # Convert existing base game traditions into civ-specific clones
        for idx, tradition in enumerate(existing_traditions):
            if not tradition.get('is_existing_tradition', False):
                continue

            base_tradition_id = tradition.get('id')
            if not base_tradition_id:
                continue

            base_tradition = base_traditions.get(base_tradition_id, {})
            new_tradition_type = f"{base_tradition_id}_{civ_suffix}"

            # Update progression tree unlocks to point at the new tradition type
            for node in existing_nodes:
                node_unlocks = node.get('unlocks', [])
                for unlock in node_unlocks:
                    if (
                        isinstance(unlock, dict)
                        and unlock.get('target_kind') == 'KIND_TRADITION'
                        and unlock.get('target_type') == base_tradition_id
                    ):
                        unlock['target_type'] = new_tradition_type

            # Generate unique builder ID
            while f'tradition_builder_{builder_counter}' in existing_builder_ids:
                builder_counter += 1
            builder_id = f'tradition_builder_{builder_counter}'
            builder_counter += 1

            base_name = base_tradition.get('name')
            base_description = base_tradition.get('description')

            # Fallback to YAML-provided localisation if base data missing
            if not base_name or not base_description:
                localizations = tradition.get('localizations', [])
                if localizations and isinstance(localizations, list):
                    loc = localizations[0]
                    if not base_name:
                        base_name = loc.get('name')
                    if not base_description:
                        base_description = loc.get('description')

            base_age = base_tradition.get('age') or tradition.get('age')
            base_is_crisis = base_tradition.get('is_crisis', None)

            base_modifiers = []
            if base_tradition.get('modifiers'):
                base_modifiers.extend(base_tradition.get('modifiers', []))
            if tradition.get('base_modifiers'):
                base_modifiers.extend(tradition.get('base_modifiers', []))
            if tradition.get('modifier_ids'):
                base_modifiers.extend(tradition.get('modifier_ids', []))

            base_modifiers = list(dict.fromkeys([m for m in base_modifiers if m]))

            builder_entry = {
                'id': builder_id,
                'tradition_type': new_tradition_type,
                'tradition': {
                    'trait_type': f'TRAIT_{civ_suffix}',
                },
                'localizations': [
                    {
                        'name': base_name or new_tradition_type.replace('TRADITION_', '').replace('_', ' ').title(),
                        'description': base_description or '',
                    }
                ],
            }

            if base_age:
                builder_entry['tradition']['age_type'] = base_age
            if base_is_crisis is not None:
                builder_entry['tradition']['is_crisis'] = base_is_crisis
            if base_modifiers:
                builder_entry['base_modifiers'] = base_modifiers

            existing_traditions[idx] = builder_entry
            existing_builder_ids.add(builder_id)
        
        # Build set of tradition IDs that should NOT be auto-created:
        # 1. Traditions with builder IDs (tradition_builder_*)
        # 2. Traditions with is_existing_tradition: true (reused from base game)
        skip_tradition_ids = set()
        for t in existing_traditions:
            builder_id = t.get('id', '')
            tradition_type = t.get('tradition_type')
            
            if builder_id.startswith('tradition_builder_'):
                # Has a builder ID, add its tradition_type to skip list
                if tradition_type:
                    skip_tradition_ids.add(tradition_type)
            elif t.get('is_existing_tradition', False):
                # Is an existing base game tradition, skip it
                # Use 'id' as the tradition type for existing traditions
                if builder_id:
                    skip_tradition_ids.add(builder_id)
        
        # Check all nodes for tradition unlocks and create missing TraditionBuilders
        traditions_to_create = {}  # {tradition_type: {data}}
        
        for node in existing_nodes:
            node_unlocks = node.get('unlocks', [])
            for unlock in node_unlocks:
                if isinstance(unlock, dict) and unlock.get('target_kind') == 'KIND_TRADITION':
                    tradition_type = unlock.get('target_type')
                    if tradition_type and tradition_type not in skip_tradition_ids:
                        # Infer age from node type
                        node_type = node.get('progression_tree_node_type', '')
                        age = 'AGE_ANTIQUITY'
                        if '_EX_' in node_type or 'EXPLORATION' in node_type:
                            age = 'AGE_EXPLORATION'
                        elif '_MO_' in node_type or 'MODERN' in node_type:
                            age = 'AGE_MODERN'
                        
                        # Infer trait from civilization_type or tradition_type
                        trait_type = None
                        civ_data = self.data.get('civilization', {})
                        civ_type = civ_data.get('civilization_type', '')
                        
                        # Extract civ name from civilization_type or tradition_type
                        civ_name = None
                        if civ_type:
                            civ_name = civ_type.replace('CIVILIZATION_', '')
                        elif tradition_type.startswith('TRADITION_'):
                            # Try to extract from tradition name
                            parts = tradition_type.replace('TRADITION_', '').split('_')
                            if parts:
                                civ_name = parts[0]
                        
                        if civ_name:
                            trait_type = f'TRAIT_{civ_name}'
                        
                        # Generate tradition builder data
                        tradition_name = tradition_type.replace('TRADITION_', '').replace('_', ' ').title()
                        traditions_to_create[tradition_type] = {
                            'tradition_type': tradition_type,
                            'tradition': {
                                'age_type': age,
                                'trait_type': trait_type if trait_type else 'TRAIT_CUSTOM',
                            },
                            'localizations': [{
                                'name': tradition_name,
                                'description': 'Custom tradition for progression tree'
                            }]
                        }
        
        # Add created traditions to data
        if traditions_to_create:
            if 'traditions' not in self.data:
                self.data['traditions'] = []
            
            # Generate unique IDs for tradition builders
            existing_ids = {t.get('id') for t in existing_traditions if t.get('id')}
            tradition_counter = 1
            
            for tradition_type, tradition_data in traditions_to_create.items():
                # Generate unique builder ID
                while f'tradition_builder_{tradition_counter}' in existing_ids:
                    tradition_counter += 1
                builder_id = f'tradition_builder_{tradition_counter}'
                tradition_counter += 1
                
                # Create tradition builder entry
                tradition_data['id'] = builder_id
                self.data['traditions'].append(tradition_data)
                skip_tradition_ids.add(tradition_type)
        
    def indent(self) -> str:
        """Return current indentation string."""
        return '    ' * self.indent_level
    
    def add_line(self, line: str = '') -> None:
        """Add a line with current indentation."""
        if line:
            self.lines.append(f'{self.indent()}{line}')
        else:
            self.lines.append('')
    
    def format_value(self, value: Any) -> str:
        """Format a Python value for code generation."""
        if isinstance(value, str):
            # Handle variable references like ${metadata.id}
            if value.startswith('${') and value.endswith('}'):
                ref = value[2:-1]
                parts = ref.split('.')
                if parts[0] == 'metadata':
                    return f"mod.mod_id"
                elif parts[0] == 'constants':
                    return parts[1].upper()
            # Use repr() which properly escapes all special characters including newlines
            return repr(value)
        elif isinstance(value, bool):
            return str(value)
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, list):
            if not value:
                return '[]'
            # Check if it's a simple list of strings
            if all(isinstance(v, str) for v in value):
                items = ', '.join(repr(v) for v in value)
                return f'[{items}]'
            # Otherwise format as multi-line
            return self.format_list(value)
        elif isinstance(value, dict):
            return self.format_dict(value)
        elif value is None:
            return 'None'
        return str(value)
    
    def format_list(self, lst: list[Any], inline: bool = False) -> str:
        """Format a list as Python code."""
        if not lst:
            return '[]'
        
        if inline:
            items = ', '.join(self.format_value(v) for v in lst)
            return f'[{items}]'
        
        # Multi-line list
        result = '[\n'
        self.indent_level += 1
        for item in lst:
            result += f'{self.indent()}{self.format_value(item)},\n'
        self.indent_level -= 1
        result += f'{self.indent()}]'
        return result
    
    def format_dict(self, dct: dict[str, Any], inline: bool = False) -> str:
        """Format a dictionary as Python code."""
        if not dct:
            return '{}'
        
        if inline and len(dct) <= 2:
            items = ', '.join(f"'{k}': {self.format_value(v)}" for k, v in dct.items())
            return f'{{{items}}}'
        
        # Multi-line dict
        result = '{\n'
        self.indent_level += 1
        for key, value in dct.items():
            formatted_value = self.format_value(value)
            result += f"{self.indent()}'{key}': {formatted_value},\n"
        self.indent_level -= 1
        result += f'{self.indent()}}}'
        return result
    
    def generate_docstring(self) -> None:
        """Generate module docstring."""
        metadata = self.data.get('metadata', {})
        name = metadata.get('name', 'Civilization')
        description = metadata.get('description', '')
        
        self.add_line('"""')
        self.add_line(f'{name} Civilization - Generated from YAML')
        self.add_line()
        self.add_line(description)
        self.add_line('"""')
        self.add_line()
    
    def generate_imports(self) -> None:
        """Generate import statements."""
        self.add_line('from civ7_modding_tools import Mod, ActionGroupBundle')
        self.add_line('from civ7_modding_tools.builders import (')
        self.indent_level += 1
        self.add_line('CivilizationBuilder,')
        self.add_line('UnitBuilder,')
        self.add_line('ConstructibleBuilder,')
        self.add_line('UniqueQuarterBuilder,')
        self.add_line('ProgressionTreeBuilder,')
        self.add_line('ProgressionTreeNodeBuilder,')
        self.add_line('ModifierBuilder,')
        self.add_line('ImportFileBuilder,')
        self.add_line('TraditionBuilder,')
        self.indent_level -= 1
        self.add_line(')')
        self.add_line('from civ7_modding_tools.localizations import (')
        self.indent_level += 1
        self.add_line('ModuleLocalization,')
        self.add_line('TraditionLocalization,')
        self.indent_level -= 1
        self.add_line(')')
        self.add_line()
    
    def generate_constants(self) -> None:
        """Generate constant definitions."""
        constants = self.data.get('constants', {})
        if not constants:
            return
        
        self.add_line('# Constants')
        for name, value in constants.items():
            const_name = name.upper()
            if isinstance(value, list):
                self.add_line(f'{const_name} = [')
                self.indent_level += 1
                for item in value:
                    self.add_line(f"'{item}',")
                self.indent_level -= 1
                self.add_line(']')
            else:
                self.add_line(f"{const_name} = {self.format_value(value)}")
        self.add_line()
    
    def generate_module_localization(self) -> None:
        """Generate module localization."""
        mod_loc = self.data.get('module_localization', {})
        if not mod_loc:
            return
        
        self.add_line('# Module localization')
        self.add_line('MODULE_LOC = ModuleLocalization(')
        self.indent_level += 1
        for key, value in mod_loc.items():
            self.add_line(f'{key}="{value}",')
        self.indent_level -= 1
        self.add_line(')')
        self.add_line()
    
    def generate_mod_creation(self) -> None:
        """Generate Mod instance creation."""
        metadata = self.data.get('metadata', {})
        mod_loc = self.data.get('module_localization', {})
        
        self.add_line('# Mod metadata and setup')
        self.add_line('mod = Mod({')
        self.indent_level += 1
        for key, value in metadata.items():
            self.add_line(f"'{key}': {self.format_value(value)},")
        if mod_loc:
            self.add_line("'module_localizations': MODULE_LOC,")
        self.indent_level -= 1
        self.add_line('})')
        self.add_line()
    
    def generate_action_group(self) -> None:
        """Generate action group bundle."""
        action_group_data = self.data.get('action_group')
        if not action_group_data:
            return
        
        # Handle both dict and string formats
        if isinstance(action_group_data, dict):
            action_group = action_group_data.get('action_group_id')
        else:
            action_group = action_group_data
        
        if not action_group:
            return
        
        self.add_line('# Action group')
        var_name = action_group.replace('AGE_', '').title()
        self.action_group_var_name = var_name  # Store for builder methods
        self.add_line(f'{var_name} = ActionGroupBundle(action_group_id=\'{action_group}\')')
        self.add_line()
    
    def generate_imports_builders(self) -> None:
        """Generate import file builders."""
        from pathlib import Path
        import os
        
        imports = self.data.get('imports', [])
        if not imports:
            return
        
        self.add_line('# Icon imports')
        
        for imp in imports:
            builder_id = imp['id']
            source_path = imp['source_path']
            
            # Convert relative paths to absolute
            # If path is relative and starts with generated_icons/, resolve it
            if not source_path.startswith('/') and not source_path.startswith('C:'):
                if 'generated_icons' in source_path:
                    # Make absolute relative to current working directory
                    resolved = str(Path(source_path).resolve())
                    source_path = resolved
            
            # Convert backslashes to forward slashes for Python code
            source_path = source_path.replace('\\', '/')
            
            self.add_line(f'{builder_id} = ImportFileBuilder()')
            self.add_line(f'{builder_id}.action_group_bundle = {self.action_group_var_name}')
            self.add_line(f'{builder_id}.fill({{')
            self.indent_level += 1
            self.add_line(f"'source_path': '{source_path}',")
            self.add_line(f"'target_name': '{imp['target_name']}'")
            self.indent_level -= 1
            self.add_line('})')
            self.add_line()
    
    def generate_modifiers(self) -> None:
        """Generate modifier builders."""
        modifiers = self.data.get('modifiers', [])
        if not modifiers:
            return
        
        # Get civ_ability_modifier_ids for special handling
        civ_ability_modifier_ids = set()
        civilization = self.data.get('civilization', {})
        if civilization and 'civ_ability_modifier_ids' in civilization:
            civ_ability_modifier_ids = set(civilization['civ_ability_modifier_ids'])
        
        # Collect modifiers unlocked via progression tree nodes with their ages
        prog_tree_modifier_ages = {}
        for node in self.data.get('progression_tree_nodes', []):
            node_type = node.get('progression_tree_node_type', '')
            # Detect age from node type pattern
            if '_EX_' in node_type or '_EXPLORATION' in node_type:
                node_age = 'AGE_EXPLORATION'
            elif '_MO_' in node_type or '_MODERN' in node_type:
                node_age = 'AGE_MODERN'
            else:
                node_age = 'AGE_ANTIQUITY'
            
            # Collect modifier IDs from unlocks with KIND_MODIFIER or KIND_MODIFIER_CUSTOM
            for unlock in node.get('unlocks', []):
                if unlock.get('target_kind') in ('KIND_MODIFIER', 'KIND_MODIFIER_CUSTOM', 'KIND_MODIFIER_COMMON'):
                    target_type = unlock.get('target_type')
                    if target_type:
                        prog_tree_modifier_ages[target_type] = node_age
        
        self.add_line('# Modifiers')
        for modifier_data in modifiers:
            builder_id = modifier_data['id']
            self.add_line(f'{builder_id} = ModifierBuilder()')
            
            # Check if modifier is unlocked via progression tree node - use that age
            if builder_id in prog_tree_modifier_ages:
                prog_tree_age = prog_tree_modifier_ages[builder_id]
                self.add_line(f'{builder_id}.action_group_bundle = ActionGroupBundle(action_group_id=\'{prog_tree_age}\')')
            else:
                # Use global action group
                self.add_line(f'{builder_id}.action_group_bundle = {self.action_group_var_name}')
            
            # Mark civ_ability modifiers as detached so they don't get linked to TRAIT_{CIV} in always.xml
            # They'll be linked to TRAIT_{CIV}_ABILITY in current.xml by CivilizationBuilder
            if builder_id in civ_ability_modifier_ids:
                self.add_line(f'{builder_id}.is_detached = True')
            
            # Build fill dict
            fill_dict = {}
            if 'modifier_type' in modifier_data:
                fill_dict['modifier_type'] = modifier_data['modifier_type']
            if 'modifier' in modifier_data:
                fill_dict['modifier'] = modifier_data['modifier']
                # Inject the ID into the modifier dict so it's available to the builder
                if 'id' not in fill_dict['modifier']:
                    fill_dict['modifier']['id'] = modifier_data['id']
            if 'modifier_strings' in modifier_data:
                fill_dict['modifier_strings'] = modifier_data['modifier_strings']
            if 'localizations' in modifier_data:
                fill_dict['localizations'] = modifier_data['localizations']
            
            if fill_dict:
                self.add_line(f'{builder_id}.fill({{')
                self.indent_level += 1
                for key, value in fill_dict.items():
                    formatted_value = self.format_value(value)
                    self.add_line(f"'{key}': {formatted_value},")
                self.indent_level -= 1
                self.add_line('})')
            self.add_line()
    
    def generate_traditions(self) -> None:
        """Generate tradition builders."""
        traditions = self.data.get('traditions', [])
        if not traditions:
            return
        
        self.add_line('# Traditions')
        
        for tradition_data in traditions:
            # Skip traditions marked as existing (base game traditions being reused)
            if tradition_data.get('is_existing_tradition', False):
                continue
            
            # Skip traditions without builder IDs (malformed entries)
            if 'id' not in tradition_data:
                continue
            
            builder_id = tradition_data['id']
            self.add_line(f'{builder_id} = TraditionBuilder()')
            self.add_line(f'{builder_id}.action_group_bundle = {self.action_group_var_name}')
            
            # Build fill dict
            fill_dict = {k: v for k, v in tradition_data.items() if k not in ['id', 'bindings', 'is_existing_tradition']}
            
            self.add_line(f'{builder_id}.fill({{')
            self.indent_level += 1
            for key, value in fill_dict.items():
                if key == 'localizations':
                    # Handle TraditionLocalization objects
                    self.add_line(f"'{key}': [")
                    self.indent_level += 1
                    for loc in value:
                        self.add_line('TraditionLocalization(')
                        self.indent_level += 1
                        for loc_key, loc_value in loc.items():
                            self.add_line(f"{loc_key}='{loc_value}',")
                        self.indent_level -= 1
                        self.add_line(')')
                    self.indent_level -= 1
                    self.add_line('],')
                else:
                    formatted_value = self.format_value(value)
                    self.add_line(f"'{key}': {formatted_value},")
            self.indent_level -= 1
            self.add_line('})')
            
            # Handle bindings
            if 'bindings' in tradition_data:
                bindings = tradition_data['bindings']
                binding_list = ', '.join(bindings)
                self.add_line(f'{builder_id}.bind([{binding_list}])')
            
            self.add_line()
    
    def generate_units(self) -> None:
        """Generate unit builders."""
        units = self.data.get('units', [])
        if not units:
            return
        
        # Build upgrade chain map to detect which units are part of upgrade chains
        upgrade_chains = self._detect_upgrade_chains(units)
        
        self.add_line('# Units')
        
        for unit_data in units:
            builder_id = unit_data['id']
            unit_type = unit_data.get('unit_type')
            
            self.add_line(f'{builder_id} = UnitBuilder()')
            self.add_line(f'{builder_id}.action_group_bundle = {self.action_group_var_name}')
            
            # Build fill dict
            fill_dict = {k: v for k, v in unit_data.items() if k not in ['id', 'bindings']}
            
            # Set base_unit_type for units in upgrade chains
            if unit_type and unit_type in upgrade_chains:
                fill_dict['base_unit_type'] = upgrade_chains[unit_type]
            
            self.add_line(f'{builder_id}.fill({{')
            self.indent_level += 1
            for key, value in fill_dict.items():
                formatted_value = self.format_value(value)
                self.add_line(f"'{key}': {formatted_value},")
            self.indent_level -= 1
            self.add_line('})')
            self.add_line()
    
    def _detect_upgrade_chains(self, units: list[dict[str, Any]]) -> dict[str, str]:
        """
        Detect upgrade chains and map each unit to its chain root.
        
        Args:
            units: List of unit data dictionaries
            
        Returns:
            Dictionary mapping unit_type to base_unit_type (chain root)
        """
        # Build map of unit_type -> upgrade_unit
        upgrades: dict[str, str] = {}
        unit_types = set()
        
        for unit_data in units:
            unit_type = unit_data.get('unit_type')
            if not unit_type:
                continue
            
            unit_types.add(unit_type)
            unit_upgrade = unit_data.get('unit_upgrade', {})
            if isinstance(unit_upgrade, dict):
                upgrade_unit = unit_upgrade.get('upgrade_unit')
                if upgrade_unit:
                    upgrades[unit_type] = upgrade_unit
        
        # Find root of each chain (units that are upgraded to but not in our list)
        chains: dict[str, str] = {}
        
        for unit_type in unit_types:
            # Find the root by walking backwards
            root = unit_type
            visited = {unit_type}
            
            # Walk backwards through the chain
            for potential_parent in unit_types:
                if potential_parent in upgrades and upgrades[potential_parent] == unit_type:
                    if potential_parent not in visited:
                        root = potential_parent
                        visited.add(potential_parent)
            
            # Continue walking backwards until we find the root
            while True:
                found_parent = False
                for potential_parent in unit_types:
                    if potential_parent in upgrades and upgrades[potential_parent] == root:
                        if potential_parent not in visited:
                            root = potential_parent
                            visited.add(potential_parent)
                            found_parent = True
                            break
                if not found_parent:
                    break
            
            # If this unit is part of an upgrade chain (either upgrades or is upgraded to), map it
            if unit_type in upgrades or any(upgrades.get(u) == unit_type for u in unit_types):
                chains[unit_type] = root
        
        return chains
    
    def generate_constructibles(self) -> None:
        """Generate constructible builders."""
        constructibles = self.data.get('constructibles', [])
        if not constructibles:
            return
        
        self.add_line('# Constructibles')
        
        for constructible_data in constructibles:
            builder_id = constructible_data['id']
            self.add_line(f'{builder_id} = ConstructibleBuilder()')
            self.add_line(f'{builder_id}.action_group_bundle = {self.action_group_var_name}')
            
            # Build fill dict
            fill_dict = {k: v for k, v in constructible_data.items() if k not in ['id', 'bindings']}
            
            self.add_line(f'{builder_id}.fill({{')
            self.indent_level += 1
            for key, value in fill_dict.items():
                formatted_value = self.format_value(value)
                self.add_line(f"'{key}': {formatted_value},")
            self.indent_level -= 1
            self.add_line('})')
            self.add_line()
    
    def generate_unique_quarters(self) -> None:
        """Generate unique quarter builders."""
        unique_quarters = self.data.get('unique_quarters', [])
        if not unique_quarters:
            return
        
        self.add_line('# Unique Quarters')
        
        for quarter_data in unique_quarters:
            builder_id = quarter_data['id']
            self.add_line(f'{builder_id} = UniqueQuarterBuilder()')
            self.add_line(f'{builder_id}.action_group_bundle = {self.action_group_var_name}')
            
            # Build fill dict
            fill_dict = {k: v for k, v in quarter_data.items() if k not in ['id', 'bindings']}
            
            self.add_line(f'{builder_id}.fill({{')
            self.indent_level += 1
            for key, value in fill_dict.items():
                formatted_value = self.format_value(value)
                self.add_line(f"'{key}': {formatted_value},")
            self.indent_level -= 1
            self.add_line('})')
            self.add_line()
    
    def generate_progression_tree_nodes(self) -> None:
        """Generate progression tree node builders."""
        nodes = self.data.get('progression_tree_nodes', [])
        if not nodes:
            return
        
        # Collect custom modifier IDs (defined in YAML)
        custom_modifier_ids = {mod['id'] for mod in self.data.get('modifiers', [])}
        
        self.add_line('# Progression tree nodes')
        
        for node_data in nodes:
            builder_id = node_data['id']
            self.add_line(f'{builder_id} = ProgressionTreeNodeBuilder()')
            self.add_line(f'{builder_id}.action_group_bundle = {self.action_group_var_name}')
            
            # Build fill dict
            fill_dict = {k: v for k, v in node_data.items() if k not in ['id', 'bindings']}
            
            self.add_line(f'{builder_id}.fill({{')
            self.indent_level += 1
            for key, value in fill_dict.items():
                formatted_value = self.format_value(value)
                self.add_line(f"'{key}': {formatted_value},")
            self.indent_level -= 1
            self.add_line('})')
            
            # Collect CUSTOM modifiers from unlocks to bind them (so they generate game-effects.xml)
            # Only bind modifiers that are defined in this mod's YAML
            modifiers_to_bind = []
            for unlock in node_data.get('unlocks', []):
                if unlock.get('target_kind') in ('KIND_MODIFIER', 'KIND_MODIFIER_CUSTOM', 'KIND_MODIFIER_COMMON'):
                    target_type = unlock.get('target_type')
                    if target_type and target_type in custom_modifier_ids:
                        modifiers_to_bind.append(target_type)
            
            # Handle explicit bindings
            bindings = list(node_data.get('bindings', []))
            
            # Add custom modifier unlocks to bindings
            bindings.extend(modifiers_to_bind)
            
            # Generate bind call if we have any bindings
            if bindings:
                binding_list = ', '.join(bindings)
                self.add_line(f'{builder_id}.bind([{binding_list}])')
            
            self.add_line()
    
    def generate_progression_trees(self) -> None:
        """Generate progression tree builders."""
        trees = self.data.get('progression_trees', [])
        if not trees:
            return
        
        self.add_line('# Progression trees')
        
        for tree_data in trees:
            builder_id = tree_data['id']
            self.add_line(f'{builder_id} = ProgressionTreeBuilder()')
            self.add_line(f'{builder_id}.action_group_bundle = {self.action_group_var_name}')
            
            # Build fill dict
            fill_dict = {k: v for k, v in tree_data.items() if k not in ['id', 'bindings']}
            
            self.add_line(f'{builder_id}.fill({{')
            self.indent_level += 1
            for key, value in fill_dict.items():
                formatted_value = self.format_value(value)
                self.add_line(f"'{key}': {formatted_value},")
            self.indent_level -= 1
            self.add_line('})')
            
            # Handle bindings
            if 'bindings' in tree_data:
                bindings = tree_data['bindings']
                binding_list = ', '.join(bindings)
                self.add_line(f'{builder_id}.bind([{binding_list}])')
            
            self.add_line()
    
    def generate_civilization(self) -> None:
        """Generate civilization builder."""
        civ_data = self.data.get('civilization')
        if not civ_data:
            return
        
        self.add_line('# Civilization')
        builder_id = civ_data.get('id', 'civilization')
        
        self.add_line(f'{builder_id} = CivilizationBuilder()')
        self.add_line(f'{builder_id}.action_group_bundle = {self.action_group_var_name}')
        
        # Fields that should be nested inside 'civilization' dict
        nested_fields = {'civ_ability_name', 'civ_ability_modifier_ids', 'civ_ability_description'}
        
        # Build fill dict (exclude bindings - they're auto-generated)
        # Separate top-level fields from nested civilization fields
        fill_dict = {}
        civilization_dict = {}
        
        for key, value in civ_data.items():
            if key in ['id', 'bindings']:
                continue
            elif key in nested_fields:
                civilization_dict[key] = value
            else:
                fill_dict[key] = value
        
        # Auto-generate civ_ability_description from civ_ability_modifier_ids if not provided
        if 'civ_ability_modifier_ids' in civilization_dict and 'civ_ability_description' not in civilization_dict:
            modifier_ids = civilization_dict['civ_ability_modifier_ids']
            modifier_descriptions = []
            
            # Look up descriptions from modifier definitions
            for modifier in self.data.get('modifiers', []):
                modifier_id = modifier.get('id')
                if modifier_id in modifier_ids:
                    # Get description from localizations
                    for loc in modifier.get('localizations', []):
                        if isinstance(loc, dict) and 'description' in loc:
                            modifier_descriptions.append(loc['description'])
                            break
            
            # Format as bullet list: [BLIST][LI]item1[LI]item2[/LIST]
            if modifier_descriptions:
                civilization_dict['civ_ability_description'] = (
                    '[BLIST]' + ''.join(f'[LI]{desc}' for desc in modifier_descriptions) + '[/LIST]'
                )
        
        # If we have nested fields, add them as a 'civilization' key
        if civilization_dict:
            fill_dict['civilization'] = civilization_dict
        
        self.add_line(f'{builder_id}.fill({{')
        self.indent_level += 1
        for key, value in fill_dict.items():
            formatted_value = self.format_value(value)
            self.add_line(f"'{key}': {formatted_value},")
        self.indent_level -= 1
        self.add_line('})')
        
        self.add_line()
    
    def collect_all_builders(self) -> list[str]:
        """Collect all builder IDs from YAML data."""
        builders = []
        
        # Import file builders
        for imp in self.data.get('imports', []):
            builders.append(imp['id'])
        
        # Modifier builders
        for modifier in self.data.get('modifiers', []):
            builders.append(modifier['id'])
        
        # Tradition builders (skip existing base game traditions)
        for tradition in self.data.get('traditions', []):
            # Skip traditions marked as existing or without builder IDs
            if tradition.get('is_existing_tradition', False) or 'id' not in tradition:
                continue
            builders.append(tradition['id'])
        
        # Unit builders
        for unit in self.data.get('units', []):
            builders.append(unit['id'])
        
        # Constructible builders
        for constructible in self.data.get('constructibles', []):
            builders.append(constructible['id'])
        
        # Unique quarter builders
        for quarter in self.data.get('unique_quarters', []):
            builders.append(quarter['id'])
        
        # Progression tree node builders
        for node in self.data.get('progression_tree_nodes', []):
            builders.append(node['id'])
        
        # Progression tree builders
        for tree in self.data.get('progression_trees', []):
            builders.append(tree['id'])
        
        return builders
    
    def collect_bound_modifiers(self) -> set[str]:
        """Collect modifier IDs that are already bound to other entities."""
        bound = set()
        
        # Modifiers bound directly to civilization (from bindings only)
        civilization = self.data.get('civilization', {})
        if civilization:
            # Modifiers in bindings (bound to TRAIT_{CIV} in always scope)
            if 'bindings' in civilization:
                for binding in civilization['bindings']:
                    bound.add(binding)
            
            # NOTE: civ_ability_modifier_ids are NOT marked as bound here.
            # They need to be bound via .bind() so their Modifier XML definitions
            # are generated. CivilizationBuilder creates the TraitModifiers link,
            # but the actual Modifier definition comes from binding.
        
        # Modifiers bound to progression tree nodes
        for node in self.data.get('progression_tree_nodes', []):
            if 'bindings' in node:
                for binding in node['bindings']:
                    bound.add(binding)
        
        # Modifiers bound to traditions
        for tradition in self.data.get('traditions', []):
            if 'bindings' in tradition:
                for binding in tradition['bindings']:
                    bound.add(binding)
        
        # Modifiers bound to unit abilities
        for unit in self.data.get('units', []):
            if 'unit_abilities' in unit:
                for ability in unit['unit_abilities']:
                    if 'modifiers' in ability:
                        for modifier_id in ability['modifiers']:
                            bound.add(modifier_id)
        
        # Modifiers bound to constructible abilities (if implemented in future)
        for constructible in self.data.get('constructibles', []):
            if 'abilities' in constructible:
                for ability in constructible['abilities']:
                    if 'modifiers' in ability:
                        for modifier_id in ability['modifiers']:
                            bound.add(modifier_id)
        
        # Modifiers unlocked via progression tree nodes (these are handled by the tree's unlock system)
        for node in self.data.get('progression_tree_nodes', []):
            for unlock in node.get('unlocks', []):
                if unlock.get('target_kind') in ('KIND_MODIFIER', 'KIND_MODIFIER_CUSTOM', 'KIND_MODIFIER_COMMON'):
                    target_type = unlock.get('target_type')
                    if target_type:
                        bound.add(target_type)
        
        return bound
    
    def generate_bindings(self) -> None:
        """Generate automatic bindings for civilization builder."""
        civilization = self.data.get('civilization', {})
        if not civilization:
            return
        
        # Collect modifiers that are already bound elsewhere
        already_bound_modifiers = self.collect_bound_modifiers()
        
        # Collect only the top-level entities that should be bound to civilization
        to_bind = []
        
        # Units
        for unit in self.data.get('units', []):
            to_bind.append(unit['id'])
        
        # Constructibles
        for constructible in self.data.get('constructibles', []):
            to_bind.append(constructible['id'])
        
        # Unique quarters
        for quarter in self.data.get('unique_quarters', []):
            to_bind.append(quarter['id'])
        
        # Progression trees
        for tree in self.data.get('progression_trees', []):
            to_bind.append(tree['id'])
        
        # Modifiers explicitly listed in civilization.bindings
        if civilization and 'bindings' in civilization:
            for modifier_id in civilization['bindings']:
                to_bind.append(modifier_id)
        
        # Top-level modifiers (not bound to other entities)
        for modifier in self.data.get('modifiers', []):
            modifier_id = modifier['id']
            if modifier_id not in already_bound_modifiers:
                to_bind.append(modifier_id)
        
        if to_bind:
            self.add_line('# Bind all entities to civilization')
            civ_id = civilization.get('id', 'civilization')
            binding_list = ', '.join(to_bind)
            self.add_line(f'{civ_id}.bind([{binding_list}])')
            self.add_line()
    
    def generate_mod_add(self) -> None:
        """Generate mod.add() calls with all builders."""
        # Collect all builders dynamically
        all_builders = self.collect_all_builders()
        
        # Add civilization at the beginning
        civilization = self.data.get('civilization', {})
        civ_id = civilization.get('id', 'civilization')
        final_builders = [civ_id] + all_builders
        
        if not final_builders:
            return
        
        self.add_line('# Add all builders to mod')
        self.add_line('mod.add([')
        self.indent_level += 1
        for builder in final_builders:
            self.add_line(f'{builder},')
        self.indent_level -= 1
        self.add_line('])')
        self.add_line()
    
    def generate_build_call(self) -> None:
        """Generate mod.build() call."""
        build = self.data.get('build', {})
        output_dir = build.get('output_dir', None)
        
        self.add_line('# Build mod')
        self.add_line("if __name__ == '__main__':")
        self.indent_level += 1
        if output_dir:
            # Use explicit output directory if specified
            self.add_line(f"mod.build('{output_dir}')")
        else:
            # Use dynamic directory based on mod ID
            self.add_line("mod.build(f'./dist-{mod.mod_id}')")
        self.indent_level -= 1
    
    def convert(self) -> str:
        """Convert YAML to Python code."""
        self.generate_docstring()
        self.generate_imports()
        self.generate_constants()
        self.generate_module_localization()
        self.generate_mod_creation()
        self.generate_action_group()
        self.generate_imports_builders()
        self.generate_modifiers()
        self.generate_traditions()
        self.generate_units()
        self.generate_constructibles()
        self.generate_unique_quarters()
        self.generate_progression_tree_nodes()
        self.generate_progression_trees()
        self.generate_civilization()
        self.generate_bindings()
        self.generate_mod_add()
        self.generate_build_call()
        
        return '\n'.join(self.lines)


def main():
    """Main entry point for the converter."""
    parser = argparse.ArgumentParser(
        description='Convert YAML mod configuration to Python code'
    )
    parser.add_argument(
        'yaml_file',
        type=Path,
        help='Path to the YAML configuration file'
    )
    parser.add_argument(
        '-o', '--output',
        type=Path,
        default=None,
        help='Output Python file (default: <yaml_file>_generated.py)'
    )
    
    args = parser.parse_args()
    
    # Check if YAML file exists
    if not args.yaml_file.exists():
        print(f'Error: File not found: {args.yaml_file}', file=sys.stderr)
        sys.exit(1)
    
    # Determine output file
    if args.output is None:
        args.output = args.yaml_file.parent / f'{args.yaml_file.stem}_generated.py'
    
    # Load YAML
    try:
        with open(args.yaml_file, 'r', encoding='utf-8') as f:
            yaml_data = yaml.safe_load(f)
    except Exception as e:
        print(f'Error loading YAML: {e}', file=sys.stderr)
        sys.exit(1)
    
    # Convert
    converter = YamlToPyConverter(yaml_data)
    python_code = converter.convert()
    
    # Write output
    try:
        with open(args.output, 'w', encoding='utf-8') as f:
            f.write(python_code)
        print(f'Successfully generated: {args.output}')
    except Exception as e:
        print(f'Error writing output: {e}', file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
