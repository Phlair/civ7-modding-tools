"""Main Mod orchestrator for building Civilization 7 mods."""

from pathlib import Path
from typing import TYPE_CHECKING, Optional, Any
from uuid import uuid4
import xmltodict
from civ7_modding_tools.files import BaseFile, XmlFile

DEFAULT_METADATA_SOURCE = "generated by https://github.com/Phlair/civ7-modding-tools"

if TYPE_CHECKING:
    from civ7_modding_tools.builders.builders import BaseBuilder


class ActionGroupBundle:
    """
    Represents a bundling of action groups for a mod entity.
    
    Action groups control when mod content is loaded (e.g., specific ages).
    This class manages the relationship between entities and their loading criteria,
    including metadata for shell, always, current, and persist groups.
    """

    def __init__(
        self,
        action_group_id: Optional[str] = None,
        criteria_id: Optional[str] = None,
    ) -> None:
        """
        Initialize action group bundle.
        
        Args:
            action_group_id: The action group identifier (e.g., "AGE_ANTIQUITY")
            criteria_id: The criteria for loading (optional)
        """
        from uuid import uuid4
        
        self.action_group_id = action_group_id or "ALWAYS"
        self.criteria_id = criteria_id or str(uuid4())

        # Create action group metadata dictionaries (not ActionGroupNode instances)
        # These are used to tag files with their action group
        if self.action_group_id.startswith("AGE_"):
            age_name = self.action_group_id.replace("AGE_", "").lower().replace("_", "-")
            self.shell = {
                "id": str(uuid4()),
                "scope": "shell",
                "criteria": "always",
            }
            self.always = {
                "id": str(uuid4()),
                "scope": "game",
                "criteria": "always",
            }
            self.current = {
                "id": f"age-{age_name}-current",
                "scope": "game",
                "criteria": f"{age_name}-age-current",
                "age": self.action_group_id,
            }
            age_persist_map = {
                "AGE_ANTIQUITY": ["AGE_ANTIQUITY", "AGE_EXPLORATION", "AGE_MODERN"],
                "AGE_EXPLORATION": ["AGE_EXPLORATION", "AGE_MODERN"],
                "AGE_MODERN": ["AGE_MODERN"],
            }
            self.persist = {
                "id": f"age-{age_name}-persist",
                "scope": "game",
                "criteria": f"{age_name}-age-persist",
                "ages": age_persist_map.get(self.action_group_id, [self.action_group_id]),
            }
        else:
            default_criteria = criteria_id or "always"
            group_id = self.action_group_id.lower().replace("_", "-")
            self.shell = {
                "id": str(uuid4()),
                "scope": "shell",
                "criteria": "always",
            }
            self.always = {
                "id": str(uuid4()),
                "scope": "game",
                "criteria": "always",
            }
            self.current = {
                "id": group_id,
                "scope": "game",
                "criteria": default_criteria,
                "age": None,
            }
            self.persist = {
                "id": f"{group_id}-persist",
                "scope": "game",
                "criteria": f"{group_id}-persist",
            }

    def __repr__(self) -> str:
        """String representation."""
        return f"ActionGroupBundle(action_group_id={self.action_group_id!r})"


class Mod:
    """
    Main orchestrator class for creating Civilization 7 mods.
    
    Coordinates builders, files, and mod metadata generation.
    Produces .modinfo file and all mod content files.
    """

    def __init__(
        self,
        mod_id: str | dict[str, Any] = "my-mod",
        version: str = "1.0.0",
        name: str = "My Mod",
        description: str = DEFAULT_METADATA_SOURCE,
        authors: str | list[str] = DEFAULT_METADATA_SOURCE,
        affects_saved_games: bool = True,
        dependencies: Optional[list[dict[str, str]]] = None,
        enabled_by_default: bool = True,
        package: str = "",
        id: Optional[str] = None,
        module_localizations: Optional[Any] = None,
    ) -> None:
        """
        Initialize a mod.
        
        Can be called with:
        - Mod(mod_id="my-mod", version="1.0", ...) - keyword arguments
        - Mod(id="my-mod", version="1.0", ...) - using id parameter
        - Mod({"id": "my-mod", "version": "1.0", ...}) - dictionary
        
        Args:
            mod_id: Unique identifier (used in filenames and .modinfo) or dict of properties
            version: Semantic version string
            name: Human-readable mod name
            description: Mod description
            authors: Comma-separated author list or list of author strings
            affects_saved_games: Whether mod affects saved games
            dependencies: List of dependency dicts with 'id' and 'title' keys
            enabled_by_default: Whether mod is enabled by default in mod manager
            package: Package name for mod categorisation (e.g., "Gondor", "Carlisle")
            id: Alias for mod_id parameter (for convenience)
            module_localizations: ModuleLocalization object for LOC_MODULE_* entries
        """
        # Support 'id' as alias for 'mod_id'
        if id is not None and not isinstance(mod_id, dict):
            mod_id = id
        
        # Handle dictionary initialization
        if isinstance(mod_id, dict):
            config = mod_id
            self.id = config.get("id", "my-mod")
            self.mod_id = self.id
            self.version = config.get("version", "1.0.0")
            self.name = config.get("name", "My Mod")
            self.description = config.get("description") or DEFAULT_METADATA_SOURCE
            authors_config = config.get("authors") or DEFAULT_METADATA_SOURCE
            if isinstance(authors_config, list):
                self.authors = authors_config
            else:
                self.authors = [a.strip() for a in str(authors_config).split(",") if a.strip()]
            self.affects_saved_games = config.get("affects_saved_games", True)
            self.enabled_by_default = config.get("enabled_by_default", True)
            self.package = config.get("package", "")
            self.dependencies = config.get("dependencies") or [
                {"id": "base-standard", "title": "LOC_MODULE_BASE_STANDARD_NAME"}
            ]
            self.module_localizations = config.get("module_localizations")
        else:
            self.id = mod_id
            self.mod_id = mod_id
            self.version = version
            self.name = name
            self.description = description or DEFAULT_METADATA_SOURCE
            if isinstance(authors, list):
                self.authors = authors
            else:
                self.authors = [a.strip() for a in str(authors).split(",") if a.strip()]
            self.affects_saved_games = affects_saved_games
            self.enabled_by_default = enabled_by_default
            self.package = package
            self.dependencies = dependencies or [
                {"id": "base-standard", "title": "LOC_MODULE_BASE_STANDARD_NAME"}
            ]
            self.module_localizations = module_localizations
        
        self.builders: list["BaseBuilder"] = []
        self.files: list[BaseFile] = []
        self.action_groups: dict[str, dict] = {}

    def add(self, builder: "BaseBuilder | list[BaseBuilder]") -> "Mod":
        """
        Add one or more builders to the mod.
        
        Args:
            builder: Single builder or list of builders
            
        Returns:
            Self for fluent API chaining
        """
        if isinstance(builder, list):
            self.builders.extend(builder)
        else:
            self.builders.append(builder)
        return self

    def add_files(self, file: BaseFile | list[BaseFile]) -> "Mod":
        """
        Add one or more import files to the mod.
        
        Args:
            file: Single file or list of files
            
        Returns:
            Self for fluent API chaining
        """
        if isinstance(file, list):
            self.files.extend(file)
        else:
            self.files.append(file)
        return self

    def build(self, dist: str = "./dist", clear: bool = True) -> list[BaseFile]:
        """
        Build the mod and write files to disk.
        
        Processes all builders to generate files, creates .modinfo,
        and writes everything to the distribution directory.
        
        Args:
            dist: Output directory path
            clear: Whether to clear existing dist directory first
            
        Returns:
            List of all generated files including .modinfo
        """
        dist_path = Path(dist)
        
        # Clear existing directory if requested
        if clear and dist_path.exists():
            import shutil
            shutil.rmtree(dist_path)
        
        # Create distribution directory
        dist_path.mkdir(parents=True, exist_ok=True)
        
        # Build all builders to generate files
        builder_files = []
        for builder in self.builders:
            if hasattr(builder, "build"):
                generated_files = builder.build()
                if isinstance(generated_files, list):
                    builder_files.extend(generated_files)
                else:
                    builder_files.append(generated_files)
        
        # Generate module text file if using LOC keys and module_localizations is provided
        module_text_file = self._generate_module_text_file()
        if module_text_file:
            builder_files.insert(0, module_text_file)
        
        # Combine all files
        all_files = builder_files + self.files
        
        # Filter empty files
        all_files = [f for f in all_files if not f.is_empty]
        
        # Generate .modinfo
        modinfo_content = self._generate_modinfo(all_files)
        modinfo_path = f"{self.id}.modinfo"
        modinfo_file = dist_path / modinfo_path
        
        with open(modinfo_file, "w", encoding="utf-8") as f:
            f.write(modinfo_content)
        
        # Create a file object for modinfo to return
        class ModInfoFile:
            def __init__(self, name: str, path: str):
                self.name = name
                self.path = path
        
        modinfo_file_obj = ModInfoFile(modinfo_path, str(modinfo_file))
        
        # Write all generated files
        for file in all_files:
            file.write(str(dist_path))
        
        return [modinfo_file_obj] + all_files

    def _generate_module_text_file(self) -> Optional[BaseFile]:
        """
        Generate module-level localization file (text/ModuleText.xml).
        
        Creates LOC_MODULE_* entries for the mod name, description, and authors
        if module_localizations is provided. Only generates if we have data to work with.
        
        Returns:
            XmlFile with module localization entries, or None if not needed
        """
        from civ7_modding_tools.nodes.database import DatabaseNode
        from civ7_modding_tools.nodes.nodes import EnglishTextNode
        
        # Only generate if module_localizations is explicitly provided
        if not self.module_localizations:
            return None
        
        # Get nodes from module_localizations object
        if not hasattr(self.module_localizations, "get_nodes"):
            return None
        
        # Build LOC prefix from mod id
        loc_prefix = f"LOC_MODULE_{self.id.upper().replace('-', '_')}"
        
        # Get nodes from module_localizations
        node_dicts = self.module_localizations.get_nodes(loc_prefix)
        
        if not node_dicts:
            return None
        
        # Convert to EnglishTextNode objects
        row_nodes = []
        for node_dict in node_dicts:
            row_nodes.append(EnglishTextNode(
                tag=node_dict["tag"],
                text=node_dict["text"]
            ))
        
        if not row_nodes:
            return None
        
        # Create DatabaseNode with EnglishText table
        database_node = DatabaseNode()
        database_node.english_text = row_nodes
        
        # Create XmlFile with action groups for shell scope
        # Shell scope is critical - this is loaded when mod manager reads mod metadata
        module_file = XmlFile(
            path="/text/",
            name="ModuleText.xml",
            content=database_node,
            action_groups=[{
                "id": str(uuid4()),
                "scope": "shell",
                "criteria": "always",
            }]
        )
        
        return module_file
    
    def _generate_modinfo(self, files: list[BaseFile]) -> str:
        """
        Generate .modinfo XML content.
        
        Creates the mod metadata file with references to all generated files,
        organized into ActionCriteria and ActionGroups based on file action_groups.
        
        Args:
            files: List of generated files
            
        Returns:
            XML string for .modinfo file
        """
        
        # Build mod metadata structure
        properties = {}
        if self.name:
            properties["Name"] = self.name
        if self.description:
            properties["Description"] = self.description
        if self.authors:
            authors_str = ", ".join(self.authors) if isinstance(self.authors, list) else self.authors
            properties["Authors"] = authors_str
        # Note: Version is only in the root Mod element, not in Properties
        
        properties["AffectsSavedGames"] = "1" if self.affects_saved_games else "0"
        
        if self.enabled_by_default is not None:
            properties["EnabledByDefault"] = "1" if self.enabled_by_default else "0"
        
        if self.package:
            properties["Package"] = self.package
        
        # Collect all unique action groups and criteria from files
        action_groups_map: dict[str, dict] = {}  # id -> {criteria, scope, files_by_type}
        criteria_map: dict[str, dict] = {}  # criteria_id -> criteria info
        
        for file in files:
            # Determine file type for categorization
            file_type = self._get_action_type(file)
            file_path = file.mod_info_path
            
            # If file has explicit action groups, use those
            if file.action_groups:
                for action_group in file.action_groups:
                    group_id = action_group.get("id", "ALWAYS")
                    criteria_id = action_group.get("criteria", "always")
                    scope = action_group.get("scope", "game")
                    
                    # Initialize action group if needed
                    if group_id not in action_groups_map:
                        action_groups_map[group_id] = {
                            "id": group_id,
                            "scope": scope,
                            "criteria": criteria_id,
                            "files_by_type": {}
                        }
                    
                    # Add criteria to criteria map
                    if criteria_id not in criteria_map:
                        criteria_map[criteria_id] = {
                            "id": criteria_id,
                            "scope": scope,
                            "age": action_group.get("age"),
                            "ages": action_group.get("ages"),
                        }
                    
                    # Initialize file type if needed
                    if file_type not in action_groups_map[group_id]["files_by_type"]:
                        action_groups_map[group_id]["files_by_type"][file_type] = []
                    
                    # Add file to action group
                    action_groups_map[group_id]["files_by_type"][file_type].append(file_path)
            else:
                # Default: use ALWAYS action group
                group_id = "ALWAYS"
                criteria_id = "always"
                scope = "game"
                
                if group_id not in action_groups_map:
                    action_groups_map[group_id] = {
                        "id": group_id,
                        "scope": scope,
                        "criteria": criteria_id,
                        "files_by_type": {}
                    }
                
                if criteria_id not in criteria_map:
                    criteria_map[criteria_id] = {
                        "id": criteria_id,
                        "scope": scope,
                        "age": None,
                        "ages": None,
                    }
                
                if file_type not in action_groups_map[group_id]["files_by_type"]:
                    action_groups_map[group_id]["files_by_type"][file_type] = []
                
                action_groups_map[group_id]["files_by_type"][file_type].append(file_path)
        
        # Create ActionCriteria
        action_criteria_list = []
        for criteria_id, criteria_info in criteria_map.items():
            criteria_entry = {"@id": criteria_id}
            
            # Add appropriate child element based on criteria type
            ages = criteria_info.get("ages")
            if criteria_id == "always":
                criteria_entry["AlwaysMet"] = None
            elif ages:
                criteria_entry["AgeInUse"] = ages
            elif criteria_info.get("age"):
                criteria_entry["AgeInUse"] = criteria_info["age"]
            else:
                criteria_entry["AlwaysMet"] = None
            
            action_criteria_list.append(criteria_entry)
        
        # Create ActionGroups from categorized files
        action_groups_list = []
        type_to_action = {
            "xml": "UpdateDatabase",
            "visual-remap": "UpdateVisualRemaps",
            "icons": "UpdateIcons",
            "png": "UpdateIcons",
            "dds": "UpdateIcons",
            "localization": "UpdateText",
            "import": "ImportFiles",
            "sql": "ImportFiles",
            "lua": "ImportFiles",
        }
        
        for group_id, group_info in action_groups_map.items():
            actions = {}
            
            # Build actions for this group
            for file_type, files_in_type in group_info["files_by_type"].items():
                action_name = type_to_action.get(file_type, "ImportFiles")
                
                if action_name not in actions:
                    actions[action_name] = {"Item": []}
                
                # Ensure Item is a list
                if not isinstance(actions[action_name]["Item"], list):
                    actions[action_name]["Item"] = [actions[action_name]["Item"]]
                
                actions[action_name]["Item"].extend(files_in_type)
            
            # Only add action group if it has content
            if actions:
                action_order = [
                    "UpdateDatabase",
                    "UpdateVisualRemaps",
                    "UpdateIcons",
                    "UpdateText",
                    "ImportFiles",
                ]
                ordered_actions = {
                    action_name: actions[action_name]
                    for action_name in action_order
                    if action_name in actions
                }
                action_group_entry = {
                    "@id": group_id,
                    "@scope": group_info["scope"],
                    "@criteria": group_info["criteria"],
                }
                
                # Add actions
                if ordered_actions:
                    action_group_entry["Actions"] = ordered_actions
                
                action_groups_list.append(action_group_entry)
        
        # Build mod structure
        mod_dict = {
            "@id": self.id,
            "@version": self.version,
            "@xmlns": "ModInfo",
        }
        
        if properties:
            mod_dict["Properties"] = properties

        # Add References element (empty for now, can be populated later)
        mod_dict["References"] = {}

        # Add Dependencies
        if self.dependencies:
            dependency_list = []
            for dep in self.dependencies:
                if isinstance(dep, dict):
                    dependency_list.append({"@id": dep.get("id"), "@title": dep.get("title")})
                else:
                    # Handle string dependency IDs (default title)
                    dependency_list.append({"@id": str(dep), "@title": "LOC_MODULE_NAME"})
            
            if len(dependency_list) == 1:
                mod_dict["Dependencies"] = {"Mod": dependency_list[0]}
            else:
                mod_dict["Dependencies"] = {"Mod": dependency_list}
        
        # Add ActionCriteria if we have any files
        if files:
            mod_dict["ActionCriteria"] = {"Criteria": action_criteria_list}
        
        # Add ActionGroups if we have any
        if action_groups_list:
            mod_dict["ActionGroups"] = {"ActionGroup": action_groups_list}
        
        # Wrap in Mod element
        output = {"Mod": mod_dict}
        
        # Generate XML
        xml_str = xmltodict.unparse(
            output,
            pretty=True,
            indent="    ",
            full_document=True,
            encoding="UTF-8",
        )
        
        # xmltodict.unparse already includes XML declaration, so don't add it again
        return xml_str

    def _get_action_type(self, file: BaseFile) -> str:
        """
        Determine the action type for a file based on its name and path.
        
        Args:
            file: The file to categorize
            
        Returns:
            File type string (xml, png, dds, localization, visual-remap, icons, import, sql, lua)
        """
        filename_lower = file.name.lower()
        path_lower = file.path.lower()

        # Imports should always map to ImportFiles, regardless of extension
        if "import" in path_lower:
            return "import"
        
        # Check for visual-remap files first (they need UpdateVisualRemaps action)
        if "visual-remap" in filename_lower or "visual_remap" in filename_lower:
            return "visual-remap"
        
        # Check for icon files (they need UpdateIcons action)
        if "icons.xml" in filename_lower:
            return "icons"
        
        if filename_lower.endswith(".xml"):
            # Check if it's a localization or module text file (needs UpdateText action)
            if "localization" in path_lower or "localization" in filename_lower or "moduletext" in filename_lower:
                return "localization"
            # Default XML files use UpdateDatabase
            return "xml"
        elif filename_lower.endswith(".png"):
            return "png"
        elif filename_lower.endswith(".dds"):
            return "dds"
        elif filename_lower.endswith(".sql"):
            return "sql"
        elif filename_lower.endswith(".lua"):
            return "lua"
        else:
            # Default to import for unknown types
            return "import"

    def __repr__(self) -> str:
        """String representation."""
        return f"Mod(id={self.id!r}, version={self.version!r})"
