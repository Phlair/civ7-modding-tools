"""Main Mod orchestrator for building Civilization 7 mods."""

from pathlib import Path
from typing import TYPE_CHECKING, Optional, Any
from uuid import uuid4
import xmltodict
from civ7_modding_tools.files import BaseFile, XmlFile

DEFAULT_METADATA_SOURCE = "generated by https://github.com/Phlair/civ7-modding-tools"

if TYPE_CHECKING:
    from civ7_modding_tools.builders.builders import BaseBuilder


class ActionGroupBundle:
    """
    Represents a bundling of action groups for a mod entity.
    
    Action groups control when mod content is loaded (e.g., specific ages).
    This class manages the relationship between entities and their loading criteria,
    including metadata for shell, always, current, and persist groups.
    """

    def __init__(
        self,
        action_group_id: Optional[str] = None,
        criteria_id: Optional[str] = None,
    ) -> None:
        """
        Initialize action group bundle.
        
        Args:
            action_group_id: The action group identifier (e.g., "AGE_ANTIQUITY")
            criteria_id: The criteria for loading (optional)
        """
        from uuid import uuid4
        
        self.action_group_id = action_group_id or "ALWAYS"
        self.criteria_id = criteria_id or str(uuid4())
        
        # Create action group metadata dictionaries (not ActionGroupNode instances)
        # These are used to tag files with their action group
        self.shell = {
            "id": f"SHELL_{self.action_group_id}",
            "scope": "shell",
            "criteria": f"CRITERIA_SHELL_{self.criteria_id}",
        }
        
        self.always = {
            "id": f"ALWAYS_{self.action_group_id}",
            "scope": "game",
            "criteria": "CRITERIA_ALWAYS",
        }
        
        self.current = {
            "id": f"CURRENT_{self.action_group_id}",
            "scope": "game",
            "criteria": f"CRITERIA_{self.action_group_id}",
            "age": self.action_group_id if self.action_group_id.startswith("AGE_") else None,
        }
        
        self.persist = {
            "id": f"PERSIST_{self.action_group_id}",
            "scope": "game",
            "criteria": f"CRITERIA_PERSIST_{self.criteria_id}",
        }

    def __repr__(self) -> str:
        """String representation."""
        return f"ActionGroupBundle(action_group_id={self.action_group_id!r})"


class Mod:
    """
    Main orchestrator class for creating Civilization 7 mods.
    
    Coordinates builders, files, and mod metadata generation.
    Produces .modinfo file and all mod content files.
    """

    def __init__(
        self,
        mod_id: str | dict[str, Any] = "my-mod",
        version: str = "1.0.0",
        name: str = "My Mod",
        description: str = DEFAULT_METADATA_SOURCE,
        authors: str = DEFAULT_METADATA_SOURCE,
        affects_saved_games: bool = True,
    ) -> None:
        """
        Initialize a mod.
        
        Can be called with:
        - Mod(mod_id="my-mod", version="1.0", ...) - keyword arguments
        - Mod({"id": "my-mod", "version": "1.0", ...}) - dictionary
        
        Args:
            mod_id: Unique identifier (used in filenames and .modinfo) or dict of properties
            version: Semantic version string
            name: Human-readable mod name
            description: Mod description
            authors: Comma-separated author list
            affects_saved_games: Whether mod affects saved games
        """
        # Handle dictionary initialization
        if isinstance(mod_id, dict):
            config = mod_id
            self.mod_id = config.get("id", "my-mod")
            self.version = config.get("version", "1.0.0")
            self.name = config.get("name", "My Mod")
            self.description = config.get("description") or DEFAULT_METADATA_SOURCE
            self.authors = config.get("authors") or DEFAULT_METADATA_SOURCE
            self.affects_saved_games = config.get("affects_saved_games", True)
        else:
            self.mod_id = mod_id
            self.version = version
            self.name = name
            self.description = description or DEFAULT_METADATA_SOURCE
            self.authors = authors or DEFAULT_METADATA_SOURCE
            self.affects_saved_games = affects_saved_games
        
        self.builders: list["BaseBuilder"] = []
        self.files: list[BaseFile] = []
        self.action_groups: dict[str, dict] = {}

    def add(self, builder: "BaseBuilder | list[BaseBuilder]") -> "Mod":
        """
        Add one or more builders to the mod.
        
        Args:
            builder: Single builder or list of builders
            
        Returns:
            Self for fluent API chaining
        """
        if isinstance(builder, list):
            self.builders.extend(builder)
        else:
            self.builders.append(builder)
        return self

    def add_files(self, file: BaseFile | list[BaseFile]) -> "Mod":
        """
        Add one or more import files to the mod.
        
        Args:
            file: Single file or list of files
            
        Returns:
            Self for fluent API chaining
        """
        if isinstance(file, list):
            self.files.extend(file)
        else:
            self.files.append(file)
        return self

    def build(self, dist: str = "./dist", clear: bool = True) -> None:
        """
        Build the mod and write files to disk.
        
        Processes all builders to generate files, creates .modinfo,
        and writes everything to the distribution directory.
        
        Args:
            dist: Output directory path
            clear: Whether to clear existing dist directory first
        """
        dist_path = Path(dist)
        
        # Clear existing directory if requested
        if clear and dist_path.exists():
            import shutil
            shutil.rmtree(dist_path)
        
        # Create distribution directory
        dist_path.mkdir(parents=True, exist_ok=True)
        
        # Build all builders to generate files
        builder_files = []
        for builder in self.builders:
            if hasattr(builder, "build"):
                generated_files = builder.build()
                if isinstance(generated_files, list):
                    builder_files.extend(generated_files)
                else:
                    builder_files.append(generated_files)
        
        # Combine all files
        all_files = builder_files + self.files
        
        # Filter empty files
        all_files = [f for f in all_files if not f.is_empty]
        
        # Generate .modinfo
        modinfo_content = self._generate_modinfo(all_files)
        modinfo_file = dist_path / f"{self.mod_id}.modinfo"
        
        with open(modinfo_file, "w", encoding="utf-8") as f:
            f.write(modinfo_content)
        
        # Write all generated files
        for file in all_files:
            file.write(str(dist_path))

    def _generate_modinfo(self, files: list[BaseFile]) -> str:
        """
        Generate .modinfo XML content.
        
        Creates the mod metadata file with references to all generated files,
        organized into ActionCriteria and ActionGroups based on file action_groups.
        
        Args:
            files: List of generated files
            
        Returns:
            XML string for .modinfo file
        """
        
        # Build mod metadata structure
        properties = {}
        if self.name:
            properties["Name"] = self.name
        if self.description:
            properties["Description"] = self.description
        if self.authors:
            properties["Authors"] = self.authors
        if self.version:
            properties["Version"] = self.version
        
        properties["AffectsSavedGames"] = "1" if self.affects_saved_games else "0"
        
        # Collect all unique action groups and criteria from files
        action_groups_map: dict[str, dict] = {}  # id -> {criteria, scope, files_by_type}
        criteria_map: dict[str, dict] = {}  # criteria_id -> criteria info
        
        for file in files:
            # Determine file type for categorization
            file_type = self._get_action_type(file)
            file_path = file.mod_info_path
            
            # If file has explicit action groups, use those
            if file.action_groups:
                for action_group in file.action_groups:
                    group_id = action_group.get("id", "ALWAYS")
                    criteria_id = action_group.get("criteria", "CRITERIA_ALWAYS")
                    scope = action_group.get("scope", "game")
                    
                    # Initialize action group if needed
                    if group_id not in action_groups_map:
                        action_groups_map[group_id] = {
                            "id": group_id,
                            "scope": scope,
                            "criteria": criteria_id,
                            "files_by_type": {}
                        }
                    
                    # Add criteria to criteria map
                    if criteria_id not in criteria_map:
                        criteria_map[criteria_id] = {
                            "id": criteria_id,
                            "scope": scope,
                            "age": action_group.get("age"),
                        }
                    
                    # Initialize file type if needed
                    if file_type not in action_groups_map[group_id]["files_by_type"]:
                        action_groups_map[group_id]["files_by_type"][file_type] = []
                    
                    # Add file to action group
                    action_groups_map[group_id]["files_by_type"][file_type].append(file_path)
            else:
                # Default: use ALWAYS action group
                group_id = "ALWAYS"
                criteria_id = "CRITERIA_ALWAYS"
                scope = "game"
                
                if group_id not in action_groups_map:
                    action_groups_map[group_id] = {
                        "id": group_id,
                        "scope": scope,
                        "criteria": criteria_id,
                        "files_by_type": {}
                    }
                
                if criteria_id not in criteria_map:
                    criteria_map[criteria_id] = {
                        "id": criteria_id,
                        "scope": scope,
                        "age": None,
                    }
                
                if file_type not in action_groups_map[group_id]["files_by_type"]:
                    action_groups_map[group_id]["files_by_type"][file_type] = []
                
                action_groups_map[group_id]["files_by_type"][file_type].append(file_path)
        
        # Create ActionCriteria
        action_criteria_list = []
        for criteria_id, criteria_info in criteria_map.items():
            criteria_entry = {"@id": criteria_id}
            
            # Add appropriate child element based on criteria type
            if criteria_id == "CRITERIA_ALWAYS":
                criteria_entry["AlwaysMet"] = None
            elif criteria_info["age"]:
                # Age-based criteria
                criteria_entry["AgeInUse"] = criteria_info["age"]
            else:
                # Default to always met if no specific criteria
                criteria_entry["AlwaysMet"] = None
            
            action_criteria_list.append(criteria_entry)
        
        # Create ActionGroups from categorized files
        action_groups_list = []
        type_to_action = {
            "xml": "UpdateDatabase",
            "visual-remap": "UpdateVisualRemaps",
            "icons": "UpdateIcons",
            "png": "UpdateIcons",
            "dds": "UpdateIcons",
            "localization": "UpdateText",
            "import": "ImportFiles",
            "sql": "ImportFiles",
            "lua": "ImportFiles",
        }
        
        for group_id, group_info in action_groups_map.items():
            actions = {}
            
            # Build actions for this group
            for file_type, files_in_type in group_info["files_by_type"].items():
                action_name = type_to_action.get(file_type, "ImportFiles")
                
                if action_name not in actions:
                    actions[action_name] = {"Item": []}
                
                # Ensure Item is a list
                if not isinstance(actions[action_name]["Item"], list):
                    actions[action_name]["Item"] = [actions[action_name]["Item"]]
                
                actions[action_name]["Item"].extend(files_in_type)
            
            # Only add action group if it has content
            if actions:
                action_group_entry = {
                    "@id": group_id,
                    "@scope": group_info["scope"],
                    "@criteria": group_info["criteria"],
                }
                
                # Add actions
                if actions:
                    action_group_entry["Actions"] = actions
                
                action_groups_list.append(action_group_entry)
        
        # Build mod structure
        mod_dict = {
            "@id": self.mod_id,
            "@version": self.version,
            "@xmlns": "ModInfo",
        }
        
        if properties:
            mod_dict["Properties"] = properties

        # Add Dependencies (default base-standard)
        mod_dict["Dependencies"] = {
             "Mod": {"@id": "base-standard", "@title": "LOC_MODULE_BASE_STANDARD_NAME"}
        }
        
        # Add ActionCriteria if we have any files
        if files:
            mod_dict["ActionCriteria"] = {"Criteria": action_criteria_list}
        
        # Add ActionGroups if we have any
        if action_groups_list:
            mod_dict["ActionGroups"] = {"ActionGroup": action_groups_list}
        
        # Wrap in Mod element
        output = {"Mod": mod_dict}
        
        # Generate XML
        xml_str = xmltodict.unparse(
            output,
            pretty=True,
            indent="    ",
            full_document=True,
            encoding="UTF-8",
        )
        
        # xmltodict.unparse already includes XML declaration, so don't add it again
        return xml_str

    def _get_action_type(self, file: BaseFile) -> str:
        """
        Determine the action type for a file based on its name and path.
        
        Args:
            file: The file to categorize
            
        Returns:
            File type string (xml, png, dds, localization, visual-remap, icons, import, sql, lua)
        """
        filename_lower = file.name.lower()
        path_lower = file.path.lower()
        
        # Check for visual-remap files first (they need UpdateVisualRemaps action)
        if "visual-remap" in filename_lower or "visual_remap" in filename_lower:
            return "visual-remap"
        
        # Check for icon files (they need UpdateIcons action)
        if "icons.xml" in filename_lower:
            return "icons"
        
        if filename_lower.endswith(".xml"):
            # Check if it's a localization file (needs UpdateText action)
            if "localization" in path_lower or "localization" in filename_lower:
                return "localization"
            # Default XML files use UpdateDatabase
            return "xml"
        elif filename_lower.endswith(".png"):
            return "png"
        elif filename_lower.endswith(".dds"):
            return "dds"
        elif filename_lower.endswith(".sql"):
            return "sql"
        elif filename_lower.endswith(".lua"):
            return "lua"
        elif "import" in path_lower:
            return "import"
        else:
            # Default to import for unknown types
            return "import"

    def __repr__(self) -> str:
        """String representation."""
        return f"Mod(id={self.mod_id!r}, version={self.version!r})"
