"""Main Mod orchestrator for building Civilization 7 mods."""

from pathlib import Path
from typing import TYPE_CHECKING, Optional, Any
from uuid import uuid4
import xmltodict
from civ7_modding_tools.files import BaseFile, XmlFile

DEFAULT_METADATA_SOURCE = "generated by https://github.com/Phlair/civ7-modding-tools"

if TYPE_CHECKING:
    from civ7_modding_tools.builders.builders import BaseBuilder


class ActionGroupBundle:
    """
    Represents a bundling of action groups for a mod entity.
    
    Action groups control when mod content is loaded (e.g., specific ages).
    This class manages the relationship between entities and their loading criteria,
    including metadata for shell, always, current, and persist groups.
    """

    def __init__(
        self,
        action_group_id: Optional[str] = None,
        criteria_id: Optional[str] = None,
        mod_id: Optional[str] = None,
    ) -> None:
        """
        Initialize action group bundle.
        
        Args:
            action_group_id: The action group identifier (e.g., "AGE_ANTIQUITY")
            criteria_id: The criteria for loading (optional)
            mod_id: The mod identifier for generating descriptive IDs (optional)
        """
        self.action_group_id = action_group_id or "ALWAYS"
        self.criteria_id = criteria_id
        self.mod_id = mod_id

        # Create action group metadata dictionaries (not ActionGroupNode instances)
        # These are used to tag files with their action group
        if self.action_group_id.startswith("AGE_"):
            age_name = self.action_group_id.replace("AGE_", "").lower().replace("_", "-")
            
            # Generate descriptive shell ID if mod_id is provided
            shell_id = f"{self.mod_id}-shell-always" if self.mod_id else str(uuid4())
            always_id = f"{self.mod_id}-game-always" if self.mod_id else str(uuid4())
            
            self.shell = {
                "id": shell_id,
                "scope": "shell",
                "criteria": "always",
            }
            self.always = {
                "id": always_id,
                "scope": "game",
                "criteria": "always",
            }
            self.current = {
                "id": f"age-{age_name}-current",
                "scope": "game",
                "criteria": f"{age_name}-age-current",
                "age": self.action_group_id,
            }
            age_persist_map = {
                "AGE_ANTIQUITY": ["AGE_ANTIQUITY", "AGE_EXPLORATION", "AGE_MODERN"],
                "AGE_EXPLORATION": ["AGE_EXPLORATION", "AGE_MODERN"],
                "AGE_MODERN": ["AGE_MODERN"],
            }
            self.persist = {
                "id": f"age-{age_name}-persist",
                "scope": "game",
                "criteria": f"{age_name}-age-persist",
                "ages": age_persist_map.get(self.action_group_id, [self.action_group_id]),
            }
        else:
            default_criteria = criteria_id or "always"
            group_id = self.action_group_id.lower().replace("_", "-")
            
            # Generate descriptive IDs if mod_id is provided
            shell_id = f"{self.mod_id}-shell-always" if self.mod_id else str(uuid4())
            always_id = f"{self.mod_id}-game-always" if self.mod_id else str(uuid4())
            
            self.shell = {
                "id": shell_id,
                "scope": "shell",
                "criteria": "always",
            }
            self.always = {
                "id": always_id,
                "scope": "game",
                "criteria": "always",
            }
            self.current = {
                "id": group_id,
                "scope": "game",
                "criteria": default_criteria,
                "age": None,
            }
            self.persist = {
                "id": f"{group_id}-persist",
                "scope": "game",
                "criteria": f"{group_id}-persist",
            }

    def __repr__(self) -> str:
        """String representation."""
        return f"ActionGroupBundle(action_group_id={self.action_group_id!r})"
    
    def regenerate_with_mod_id(self, mod_id: str) -> None:
        """
        Regenerate shell and always group IDs using a descriptive pattern.
        
        Called after mod_id is set to ensure descriptive IDs instead of UUIDs.
        
        Args:
            mod_id: The mod identifier to use in generated IDs
        """
        if self.mod_id == mod_id:
            return  # Already set
        
        self.mod_id = mod_id
        
        # Regenerate shell and always IDs with descriptive pattern
        shell_id = f"{mod_id}-shell-always"
        always_id = f"{mod_id}-game-always"
        
        self.shell["id"] = shell_id
        self.always["id"] = always_id


class Mod:
    """
    Main orchestrator class for creating Civilization 7 mods.
    
    Coordinates builders, files, and mod metadata generation.
    Produces .modinfo file and all mod content files.
    """

    def __init__(
        self,
        mod_id: str | dict[str, Any] = "my-mod",
        version: str = "1.0.0",
        name: str = "My Mod",
        description: str = DEFAULT_METADATA_SOURCE,
        authors: str | list[str] = DEFAULT_METADATA_SOURCE,
        affects_saved_games: bool = True,
        dependencies: Optional[list[dict[str, str]]] = None,
        enabled_by_default: bool = True,
        package: str = "",
        id: Optional[str] = None,
        module_localizations: Optional[Any] = None,
    ) -> None:
        """
        Initialize a mod.
        
        Can be called with:
        - Mod(mod_id="my-mod", version="1.0", ...) - keyword arguments
        - Mod(id="my-mod", version="1.0", ...) - using id parameter
        - Mod({"id": "my-mod", "version": "1.0", ...}) - dictionary
        
        Args:
            mod_id: Unique identifier (used in filenames and .modinfo) or dict of properties
            version: Semantic version string
            name: Human-readable mod name
            description: Mod description
            authors: Comma-separated author list or list of author strings
            affects_saved_games: Whether mod affects saved games
            dependencies: List of dependency dicts with 'id' and 'title' keys
            enabled_by_default: Whether mod is enabled by default in mod manager
            package: Package name for mod categorisation (e.g., "Gondor", "Carlisle")
            id: Alias for mod_id parameter (for convenience)
            module_localizations: ModuleLocalization object for LOC_MODULE_* entries
        """
        # Support 'id' as alias for 'mod_id'
        if id is not None and not isinstance(mod_id, dict):
            mod_id = id
        
        # Handle dictionary initialization
        if isinstance(mod_id, dict):
            config = mod_id
            self.id = config.get("id", "my-mod")
            self.mod_id = self.id
            self.version = config.get("version", "1.0.0")
            self.name = config.get("name", "My Mod")
            self.description = config.get("description") or DEFAULT_METADATA_SOURCE
            authors_config = config.get("authors") or DEFAULT_METADATA_SOURCE
            if isinstance(authors_config, list):
                self.authors = authors_config
            else:
                self.authors = [a.strip() for a in str(authors_config).split(",") if a.strip()]
            self.affects_saved_games = config.get("affects_saved_games", True)
            self.enabled_by_default = config.get("enabled_by_default", True)
            self.package = config.get("package", "")
            self.dependencies = config.get("dependencies") or [
                {"id": "base-standard", "title": "LOC_MODULE_BASE_STANDARD_NAME"}
            ]
            self.module_localizations = config.get("module_localizations")
        else:
            self.id = mod_id
            self.mod_id = mod_id
            self.version = version
            self.name = name
            self.description = description or DEFAULT_METADATA_SOURCE
            if isinstance(authors, list):
                self.authors = authors
            else:
                self.authors = [a.strip() for a in str(authors).split(",") if a.strip()]
            self.affects_saved_games = affects_saved_games
            self.enabled_by_default = enabled_by_default
            self.package = package
            self.dependencies = dependencies or [
                {"id": "base-standard", "title": "LOC_MODULE_BASE_STANDARD_NAME"}
            ]
            self.module_localizations = module_localizations
        
        self.builders: list["BaseBuilder"] = []
        self.files: list[BaseFile] = []
        self.import_file_builders: list["ImportFileBuilder"] = []  # Track for modinfo generation
        self.action_groups: dict[str, dict] = {}

    def add(self, builder: "BaseBuilder | list[BaseBuilder]") -> "Mod":
        """
        Add one or more builders to the mod.
        
        Automatically injects mod_id into builder's action_group_bundle
        for generating descriptive action group IDs.
        
        Args:
            builder: Single builder or list of builders
            
        Returns:
            Self for fluent API chaining
        """
        from civ7_modding_tools.builders import ImportFileBuilder
        
        builders_to_add = builder if isinstance(builder, list) else [builder]
        
        for b in builders_to_add:
            # Inject mod_id into action group bundle if not already set
            if hasattr(b, 'action_group_bundle'):
                b.action_group_bundle.regenerate_with_mod_id(self.mod_id)
            
            # Track ImportFileBuilder instances for modinfo generation
            if isinstance(b, ImportFileBuilder):
                self.import_file_builders.append(b)
            
            self.builders.append(b)
        
        return self

    def add_files(self, file: BaseFile | list[BaseFile]) -> "Mod":
        """
        Add one or more import files to the mod.
        
        Args:
            file: Single file or list of files
            
        Returns:
            Self for fluent API chaining
        """
        if isinstance(file, list):
            self.files.extend(file)
        else:
            self.files.append(file)
        return self

    def build(self, dist: str = "./dist", clear: bool = True) -> list[BaseFile]:
        """
        Build the mod and write files to disk.
        
        Processes all builders to generate files, creates .modinfo,
        and writes everything to the distribution directory.
        
        Args:
            dist: Output directory path
            clear: Whether to clear existing dist directory first
            
        Returns:
            List of all generated files including .modinfo
        """
        from civ7_modding_tools.builders import UnitBuilder, ModifierBuilder
        
        dist_path = Path(dist)
        
        # Clear existing directory if requested
        if clear and dist_path.exists():
            import shutil
            shutil.rmtree(dist_path)
        
        # Create distribution directory
        dist_path.mkdir(parents=True, exist_ok=True)
        
        # Wire up modifiers to units that reference them in abilities
        # Build a map of modifier_id -> ModifierBuilder
        modifier_map = {}
        for builder in self.builders:
            if isinstance(builder, ModifierBuilder):
                # Get modifier ID from modifier_type field or modifier dict
                modifier_id = builder.modifier_type or builder.modifier.get('id') or builder.modifier.get('modifier_type')
                if modifier_id:
                    modifier_map[modifier_id] = builder
        
        # For each unit, find modifiers referenced in its abilities and attach them
        for builder in self.builders:
            if isinstance(builder, UnitBuilder) and hasattr(builder, 'unit_abilities'):
                for ability in builder.unit_abilities:
                    if 'modifiers' in ability:
                        for modifier_id in ability['modifiers']:
                            if modifier_id in modifier_map:
                                builder._bound_modifiers.append(modifier_map[modifier_id])
        
        # Build all builders to generate files
        builder_files = []
        for builder in self.builders:
            if hasattr(builder, "build"):
                generated_files = builder.build()
                if isinstance(generated_files, list):
                    builder_files.extend(generated_files)
                else:
                    builder_files.append(generated_files)
        
        # Generate module text file if using LOC keys and module_localizations is provided
        module_text_file = self._generate_module_text_file()
        if module_text_file:
            builder_files.insert(0, module_text_file)
        
        # Generate improvement model script if any improvements have visual_remap
        improvement_model_file = self._generate_improvement_model_script()
        if improvement_model_file:
            builder_files.append(improvement_model_file)
        
        # Combine all files
        all_files = builder_files + self.files
        
        # Filter empty files
        all_files = [f for f in all_files if not f.is_empty]
        
        # Merge and deduplicate files that share the same path+name
        all_files = self._merge_duplicate_files(all_files)
        
        # Generate .modinfo
        modinfo_content = self._generate_modinfo(all_files)
        modinfo_path = f"{self.id}.modinfo"
        modinfo_file = dist_path / modinfo_path
        
        with open(modinfo_file, "w", encoding="utf-8") as f:
            f.write(modinfo_content)
        
        # Create a file object for modinfo to return
        class ModInfoFile:
            def __init__(self, name: str, path: str):
                self.name = name
                self.path = path
        
        modinfo_file_obj = ModInfoFile(modinfo_path, str(modinfo_file))
        
        # Write all generated files
        for file in all_files:
            file.write(str(dist_path))
        
        return [modinfo_file_obj] + all_files

    def _generate_module_text_file(self) -> Optional[BaseFile]:
        """
        Generate module-level localization file (text/ModuleText.xml).
        
        Creates LOC_MODULE_* entries for the mod name, description, and authors
        if module_localizations is provided. Only generates if we have data to work with.
        
        Returns:
            XmlFile with module localization entries, or None if not needed
        """
        from civ7_modding_tools.nodes.database import DatabaseNode
        from civ7_modding_tools.nodes.nodes import EnglishTextNode
        
        # Only generate if module_localizations is explicitly provided
        if not self.module_localizations:
            return None
        
        # Get nodes from module_localizations object
        if not hasattr(self.module_localizations, "get_nodes"):
            return None
        
        # Build LOC prefix from mod id
        loc_prefix = f"LOC_MODULE_{self.id.upper().replace('-', '_')}"
        
        # Get nodes from module_localizations
        node_dicts = self.module_localizations.get_nodes(loc_prefix)
        
        if not node_dicts:
            return None
        
        # Convert to EnglishTextNode objects
        row_nodes = []
        for node_dict in node_dicts:
            row_nodes.append(EnglishTextNode(
                tag=node_dict["tag"],
                text=node_dict["text"]
            ))
        
        if not row_nodes:
            return None
        
        # Create DatabaseNode with EnglishText table
        database_node = DatabaseNode()
        database_node.english_text = row_nodes
        
        # Create XmlFile with action groups for shell scope
        # Shell scope is critical - this is loaded when mod manager reads mod metadata
        # Use descriptive ID based on mod_id
        shell_module_id = f"{self.mod_id}-shell-module"
        module_file = XmlFile(
            path="/text/",
            name="ModuleText.xml",
            content=database_node,
            action_groups=[{
                "id": shell_module_id,
                "scope": "shell",
                "criteria": "always",
            }]
        )
        
        return module_file
    
    def _generate_improvement_model_script(self) -> Optional[BaseFile]:
        """
        Generate JavaScript UI script for placing 3D models on improvements.
        
        Scans all ConstructibleBuilders for improvements with visual_remap configuration.
        Generates a single JavaScript file that dynamically places models when improvements
        are built and removes them when pillaged/removed.
        
        Returns:
            JsFile with model placement script, or None if no improvements have visual_remap
        """
        from civ7_modding_tools.builders.builders import ConstructibleBuilder
        from civ7_modding_tools.files import JsFile
        
        # Collect all improvements with visual_remap
        improvement_configs = []
        
        for builder in self.builders:
            if isinstance(builder, ConstructibleBuilder):
                # Only process improvements (not buildings) with visual_remap
                if not builder.is_building and builder.visual_remap:
                    constructible_type = builder.constructible_type
                    
                    # Get the model asset name from visual_remap
                    if isinstance(builder.visual_remap, dict):
                        model_asset = builder.visual_remap.get('to')
                    else:
                        model_asset = builder.visual_remap
                    
                    if constructible_type and model_asset:
                        improvement_configs.append({
                            'constructible_type': constructible_type,
                            'model_asset': model_asset
                        })
        
        # If no improvements with visual_remap, don't generate script
        if not improvement_configs:
            return None
        
        # Generate JavaScript class name from mod ID
        class_name = self._generate_js_class_name()
        model_group_name = self._generate_js_model_group_name()
        
        # Build the JavaScript content
        js_content = self._build_improvement_model_script(
            class_name=class_name,
            model_group_name=model_group_name,
            improvements=improvement_configs
        )
        
        # Create JsFile with UIScripts action group
        js_file = JsFile(
            path="/ui/",
            name=f"{self.id}-improvement-models.js",
            content=js_content,
            action_groups=[{
                "id": f"{self.mod_id}-improvement-models",
                "scope": "game",
                "criteria": "always",
            }]
        )
        
        return js_file
    
    def _generate_js_class_name(self) -> str:
        """
        Generate JavaScript class name from mod ID.
        
        Converts mod ID to PascalCase for class naming.
        Example: "iceni" -> "IceniImprovementModels"
        
        Returns:
            PascalCase class name
        """
        # Split on hyphens and underscores, capitalize each part
        parts = self.id.replace('_', '-').split('-')
        pascal_case = ''.join(part.capitalize() for part in parts)
        return f"{pascal_case}ImprovementModels"
    
    def _generate_js_model_group_name(self) -> str:
        """
        Generate model group name from mod ID.
        
        Converts mod ID to camelCase for model group naming.
        Example: "iceni" -> "iceniImprovements"
        
        Returns:
            camelCase model group name
        """
        # Split on hyphens and underscores
        parts = self.id.replace('_', '-').split('-')
        # First part lowercase, rest capitalized
        camel_case = parts[0].lower() + ''.join(part.capitalize() for part in parts[1:])
        return f"{camel_case}Improvements"
    
    def _build_improvement_model_script(
        self,
        class_name: str,
        model_group_name: str,
        improvements: list[dict[str, str]]
    ) -> str:
        """
        Build the JavaScript source code for improvement model placement.
        
        Args:
            class_name: JavaScript class name (PascalCase)
            model_group_name: Model group identifier (camelCase)
            improvements: List of dicts with 'constructible_type' and 'model_asset' keys
            
        Returns:
            Complete JavaScript source code as string
        """
        # Build constructible type checks for event handlers
        improvement_checks = []
        for imp in improvements:
            improvement_checks.append(
                f'    if (def.ConstructibleType === "{imp["constructible_type"]}") {{\n'
                f'      this.modelGroup.addModelAtPlot(\n'
                f'        "{imp["model_asset"]}",\n'
                f'        loc,\n'
                f'        {{ x: 0, y: 0, z: 0 }},\n'
                f'        {{ angle: 0, scale: 1 }}\n'
                f'      );\n'
                f'      this.trackedImprovements.add(key);\n'
                f'      return;\n'
                f'    }}'
            )
        
        improvement_check_code = '\n'.join(improvement_checks)
        
        # Build scan loop for existing improvements
        scan_checks = []
        for imp in improvements:
            scan_checks.append(
                f'        if (constructDef && constructDef.ConstructibleType === "{imp["constructible_type"]}") {{\n'
                f'          const loc = construct.location;\n'
                f'          const key = loc.x + "_" + loc.y;\n'
                f'          \n'
                f'          if (!this.trackedImprovements.has(key)) {{\n'
                f'            this.trackedImprovements.add(key);\n'
                f'            this.modelGroup.addModelAtPlot(\n'
                f'              "{imp["model_asset"]}",\n'
                f'              loc,\n'
                f'              {{ x: 0, y: 0, z: 0 }},\n'
                f'              {{ angle: 0, scale: 1 }}\n'
                f'            );\n'
                f'          }}\n'
                f'        }}'
            )
        
        scan_check_code = '\n'.join(scan_checks)
        
        # Build removal checks
        removal_checks = []
        for imp in improvements:
            removal_checks.append(
                f'    if (def.ConstructibleType === "{imp["constructible_type"]}") {{\n'
                f'      const loc = data.location;\n'
                f'      const key = loc.x + "_" + loc.y;\n'
                f'      \n'
                f'      if (!this.trackedImprovements.has(key)) return;\n'
                f'      this.trackedImprovements.delete(key);\n'
                f'      \n'
                f'      // Clear and rebuild all models\n'
                f'      this.modelGroup.clear();\n'
                f'      \n'
                f'      // Re-add all remaining tracked improvements\n'
                f'      for (const trackedKey of this.trackedImprovements) {{\n'
                f'        const parts = trackedKey.split("_");\n'
                f'        const x = parseInt(parts[0]);\n'
                f'        const y = parseInt(parts[1]);\n'
                f'        \n'
                f'        this.modelGroup.addModelAtPlot(\n'
                f'          "{imp["model_asset"]}",\n'
                f'          {{ x: x, y: y }},\n'
                f'          {{ x: 0, y: 0, z: 0 }},\n'
                f'          {{ angle: 0, scale: 1 }}\n'
                f'        );\n'
                f'      }}\n'
                f'      \n'
                f'      return;\n'
                f'    }}'
            )
        
        removal_check_code = '\n'.join(removal_checks)
        
        # Generate complete JavaScript
        script = f'''// {class_name} - Auto-generated improvement model manager
class {class_name} {{
  static instance = null;
  modelGroup = null;
  trackedImprovements = new Set();
  
  constructor() {{
    if ({class_name}.instance) {{
      console.warn("{class_name}: Duplicate instance attempted");
      return;
    }}
    {class_name}.instance = this;
    engine.whenReady.then(() => {{
      this.onReady();
    }});
  }}
  
  onReady() {{
    this.modelGroup = WorldUI.createModelGroup("{model_group_name}");
    
    engine.on("ConstructibleAddedToMap", this.onConstructibleAddedToMap, this);
    engine.on("ConstructibleRemovedFromMap", this.onConstructibleRemovedFromMap, this);
    engine.on("GameStarted", this.onGameStarted, this);
    
    // Also scan after a short delay in case we're loading into a game
    setTimeout(() => this.scanForExistingImprovements(), 2000);
  }}
  
  onGameStarted() {{
    this.scanForExistingImprovements();
  }}
  
  scanForExistingImprovements() {{
    if (!Players) {{
      console.warn("{class_name}: Players not available");
      return;
    }}
    
    const alivePlayers = Players.getAlive();
    if (!alivePlayers) {{
      console.warn("{class_name}: No alive players found");
      return;
    }}
    
    alivePlayers.forEach((player) => {{
      player.Constructibles?.getConstructibles().forEach((construct) => {{
        const constructDef = GameInfo.Constructibles.lookup(construct.type);
{scan_check_code}
      }});
    }});
  }}
  
  onConstructibleAddedToMap(data) {{
    const def = GameInfo.Constructibles.lookup(data.constructibleType);
    if (def == null) return;
    
    const loc = data.location;
    const key = loc.x + "_" + loc.y;
    
    if (this.trackedImprovements.has(key)) return;
    
{improvement_check_code}
  }}
  
  onConstructibleRemovedFromMap(data) {{
    const def = GameInfo.Constructibles.lookup(data.constructibleType);
    if (def == null) return;
    
{removal_check_code}
  }}
}}

const {class_name.replace('ImprovementModels', 'Models')} = new {class_name}();
'''
        
        return script
    
    def _merge_duplicate_files(self, files: list[BaseFile]) -> list[BaseFile]:
        """
        Merge files with the same path+name, deduplicating XML content.
        
        This is critical for upgrade chains where multiple units share a folder
        and have duplicate modifiers in their game-effects.xml files.
        
        Args:
            files: List of files to merge
            
        Returns:
            Deduplicated list of files
        """
        from collections import defaultdict
        from civ7_modding_tools.nodes.database import DatabaseNode
        
        # Group files by (path, name)
        file_groups: dict[tuple[str, str], list[BaseFile]] = defaultdict(list)
        for file in files:
            key = (file.path, file.name)
            file_groups[key].append(file)
        
        merged_files = []
        
        for (path, name), group in file_groups.items():
            if len(group) == 1:
                # No merging needed
                merged_files.append(group[0])
            else:
                # Merge files in this group
                merged_file = self._merge_xml_files(group)
                if merged_file:
                    merged_files.append(merged_file)
        
        return merged_files
    
    def _merge_xml_files(self, files: list[BaseFile]) -> Optional[BaseFile]:
        """
        Merge multiple XmlFile instances with the same path/name.
        
        Combines their DatabaseNode content and deduplicates based on unique identifiers.
        
        Args:
            files: List of XmlFile instances to merge
            
        Returns:
            Single merged XmlFile
        """
        from civ7_modding_tools.nodes.database import DatabaseNode
        from civ7_modding_tools.nodes.nodes import GameEffectNode
        
        if not files:
            return None
        
        # Use first file as base
        base_file = files[0]
        
        # Only merge XmlFile instances
        if not all(isinstance(f, XmlFile) for f in files):
            return base_file
        
        # Check if this is a game-effects.xml file (content is GameEffectNode)
        if isinstance(base_file.content, GameEffectNode):
            return self._merge_game_effects_files(files)
        
        # Otherwise, merge as DatabaseNode files
        # Collect all DatabaseNode content
        merged_content = DatabaseNode()
        
        # List of known table attributes on DatabaseNode
        table_attrs = [
            'types', 'type_tags', 'tags', 'traits', 'kinds',
            'civilizations', 'civilization_traits', 'civilization_tags', 'civilization_items',
            'units', 'unit_stats', 'unit_costs', 'unit_replaces', 'unit_upgrades',
            'unit_advisories', 'unit_abilities', 'unit_class_abilities',
            'unit_ability_modifiers', 'charged_unit_abilities',
            'constructibles', 'constructible_yield_changes', 'constructible_valid_districts',
            'constructible_maintenances', 'constructible_adjacency_bonuses',
            'buildings', 'improvements', 'building_attributes',
            'modifiers', 'modifier_arguments', 'game_modifiers',
            'requirement_sets', 'requirement_set_requirements', 'requirements',
            'requirement_arguments', 'english_text', 'icon_definitions',
            'progression_trees', 'progression_tree_nodes', 'progression_tree_prereqs',
            'progression_tree_node_unlocks', 'traditions', 'tradition_modifiers',
            'visual_remaps', 'ai_lists', 'ai_list_types', 'ai_favored_items',
            'leader_civ_priorities', 'loading_info_civilizations',
            'civilization_favored_wonders', 'vis_art_civilization_building_cultures',
            'vis_art_civilization_unit_cultures', 'legacy_civilizations',
            'legacy_civilization_traits', 'start_bias_biomes', 'start_bias_terrains',
            'start_bias_rivers', 'civilization_unlocks', 'leader_civilization_biases',
            'leader_unlocks', 'great_people', 'named_places', 'named_place_yield_changes',
            'city_names'
        ]
        
        for file in files:
            if not isinstance(file.content, DatabaseNode):
                continue
            
            content = file.content
            
            # Merge each table, deduplicating by unique fields
            for attr_name in table_attrs:
                if not hasattr(content, attr_name):
                    continue
                
                items = getattr(content, attr_name)
                if not items or not isinstance(items, list):
                    continue
                
                existing_items = getattr(merged_content, attr_name, None)
                if existing_items is None:
                    existing_items = []
                
                # Deduplicate based on identifying fields
                merged_items = self._deduplicate_nodes(existing_items, items, attr_name)
                setattr(merged_content, attr_name, merged_items)
            
            # Handle special _game_effects attribute (private DatabaseNode for game-effects.xml)
            if hasattr(content, '_game_effects') and content._game_effects:
                if not hasattr(merged_content, '_game_effects') or not merged_content._game_effects:
                    from civ7_modding_tools.nodes.nodes import GameEffectNode
                    merged_content._game_effects = GameEffectNode()
                
                # Merge modifiers from game effects
                if hasattr(content._game_effects, 'modifiers') and content._game_effects.modifiers:
                    existing_modifiers = getattr(merged_content._game_effects, 'modifiers', None) or []
                    merged_modifiers = self._deduplicate_nodes(
                        existing_modifiers, 
                        content._game_effects.modifiers, 
                        'modifiers'
                    )
                    merged_content._game_effects.modifiers = merged_modifiers
            
            # Handle private _game_effects attribute
            if hasattr(content, '_game_effects') and content._game_effects:
                if not hasattr(merged_content, '_game_effects') or not merged_content._game_effects:
                    from civ7_modding_tools.nodes.nodes import GameEffectNode
                    merged_content._game_effects = GameEffectNode()
                
                # Merge modifiers within _game_effects
                if hasattr(content._game_effects, 'modifiers') and content._game_effects.modifiers:
                    existing_modifiers = getattr(merged_content._game_effects, 'modifiers', None) or []
                    new_modifiers = content._game_effects.modifiers
                    merged_modifiers = self._deduplicate_nodes(existing_modifiers, new_modifiers, 'modifiers')
                    merged_content._game_effects.modifiers = merged_modifiers
        
        # Create merged file
        merged_file = XmlFile(
            path=base_file.path,
            name=base_file.name,
            content=merged_content,
            action_groups=base_file.action_groups
        )
        
        return merged_file
    
    def _merge_game_effects_files(self, files: list[BaseFile]) -> BaseFile:
        """
        Merge multiple game-effects.xml files.
        
        Args:
            files: List of XmlFile instances with GameEffectNode content
            
        Returns:
            Single merged XmlFile with deduplicated modifiers
        """
        from civ7_modding_tools.nodes.nodes import GameEffectNode
        
        base_file = files[0]
        merged_effects = GameEffectNode()
        
        all_modifiers = []
        for file in files:
            if not isinstance(file.content, GameEffectNode):
                continue
            
            if hasattr(file.content, 'modifiers') and file.content.modifiers:
                all_modifiers.extend(file.content.modifiers)
        
        # Deduplicate modifiers
        if all_modifiers:
            merged_effects.modifiers = self._deduplicate_nodes([], all_modifiers, 'modifiers')
        
        return XmlFile(
            path=base_file.path,
            name=base_file.name,
            content=merged_effects,
            action_groups=base_file.action_groups
        )
    
    def _deduplicate_nodes(self, existing: list, new: list, table_name: str) -> list:
        """
        Deduplicate nodes based on unique identifier fields.
        
        Args:
            existing: Existing node list
            new: New nodes to add
            table_name: Name of the table (for identifying unique fields)
            
        Returns:
            Merged and deduplicated list
        """
        # Map table names to their unique identifier fields
        unique_fields_map = {
            'modifiers': ['modifier_id'],
            'modifier_arguments': ['modifier_id', 'name'],
            'types': ['type_'],
            'units': ['unit_type'],
            'unit_abilities': ['unit_ability_type'],
            'unit_class_abilities': ['unit_ability_type', 'unit_class_type'],
            'requirement_sets': ['requirement_set_id'],
            'requirements': ['requirement_id'],
            'game_modifiers': ['modifier_id'],
        }
        
        unique_fields = unique_fields_map.get(table_name, [])
        
        if not unique_fields:
            # No unique fields defined, just append
            return existing + new
        
        # Build set of existing unique keys
        existing_keys = set()
        for item in existing:
            key_parts = []
            for field in unique_fields:
                value = getattr(item, field, None)
                key_parts.append(str(value) if value is not None else '')
            existing_keys.add(tuple(key_parts))
        
        # Add only new items that don't exist
        result = list(existing)
        for item in new:
            key_parts = []
            for field in unique_fields:
                value = getattr(item, field, None)
                key_parts.append(str(value) if value is not None else '')
            key = tuple(key_parts)
            
            if key not in existing_keys:
                result.append(item)
                existing_keys.add(key)
        
        return result
    
    def _generate_import_files_entries(self) -> dict[str, list[str]]:
        """
        Generate ImportFiles entries from tracked ImportFileBuilder instances.
        
        Groups import entries by scope (shell, game, always).
        
        Returns:
            Dictionary mapping scope to list of import paths
        """
        import_entries_by_scope: dict[str, list[str]] = {
            "shell": [],
            "game": [],
            "always": [],
        }
        
        for import_builder in self.import_file_builders:
            entries = import_builder.get_import_entries()
            scope = import_builder.scope
            
            if scope in import_entries_by_scope:
                import_entries_by_scope[scope].extend(entries)
        
        # Return only non-empty scopes
        return {
            scope: entries
            for scope, entries in import_entries_by_scope.items()
            if entries
        }
    
    def _generate_modinfo(self, files: list[BaseFile]) -> str:
        """
        Generate .modinfo XML content.
        
        Creates the mod metadata file with references to all generated files,
        organized into ActionCriteria and ActionGroups based on file action_groups.
        
        Args:
            files: List of generated files
            
        Returns:
            XML string for .modinfo file
        """
        
        # Build mod metadata structure
        properties = {}
        if self.name:
            properties["Name"] = self.name
        if self.description:
            properties["Description"] = self.description
        if self.authors:
            authors_str = ", ".join(self.authors) if isinstance(self.authors, list) else self.authors
            properties["Authors"] = authors_str
        # Note: Version is only in the root Mod element, not in Properties
        
        properties["AffectsSavedGames"] = "1" if self.affects_saved_games else "0"
        
        if self.enabled_by_default is not None:
            properties["EnabledByDefault"] = "1" if self.enabled_by_default else "0"
        
        if self.package:
            properties["Package"] = self.package
        
        # Collect all unique action groups and criteria from files
        action_groups_map: dict[str, dict] = {}  # id -> {criteria, scope, files_by_type}
        criteria_map: dict[str, dict] = {}  # criteria_id -> criteria info
        
        for file in files:
            # Determine file type for categorization
            file_type = self._get_action_type(file)
            file_path = file.mod_info_path
            
            # If file has explicit action groups, use those
            if file.action_groups:
                for action_group in file.action_groups:
                    group_id = action_group.get("id", "ALWAYS")
                    criteria_id = action_group.get("criteria", "always")
                    scope = action_group.get("scope", "game")
                    
                    # Initialize action group if needed
                    if group_id not in action_groups_map:
                        action_groups_map[group_id] = {
                            "id": group_id,
                            "scope": scope,
                            "criteria": criteria_id,
                            "files_by_type": {}
                        }
                    
                    # Add criteria to criteria map
                    if criteria_id not in criteria_map:
                        criteria_map[criteria_id] = {
                            "id": criteria_id,
                            "scope": scope,
                            "age": action_group.get("age"),
                            "ages": action_group.get("ages"),
                        }
                    
                    # Initialize file type if needed
                    if file_type not in action_groups_map[group_id]["files_by_type"]:
                        action_groups_map[group_id]["files_by_type"][file_type] = []
                    
                    # Add file to action group
                    action_groups_map[group_id]["files_by_type"][file_type].append(file_path)
            else:
                # Default: use ALWAYS action group
                group_id = "ALWAYS"
                criteria_id = "always"
                scope = "game"
                
                if group_id not in action_groups_map:
                    action_groups_map[group_id] = {
                        "id": group_id,
                        "scope": scope,
                        "criteria": criteria_id,
                        "files_by_type": {}
                    }
                
                if criteria_id not in criteria_map:
                    criteria_map[criteria_id] = {
                        "id": criteria_id,
                        "scope": scope,
                        "age": None,
                        "ages": None,
                    }
                
                if file_type not in action_groups_map[group_id]["files_by_type"]:
                    action_groups_map[group_id]["files_by_type"][file_type] = []
                
                action_groups_map[group_id]["files_by_type"][file_type].append(file_path)
        
        # Create ActionCriteria
        action_criteria_list = []
        for criteria_id, criteria_info in criteria_map.items():
            criteria_entry = {"@id": criteria_id}
            
            # Add appropriate child element based on criteria type
            ages = criteria_info.get("ages")
            if criteria_id == "always":
                criteria_entry["AlwaysMet"] = None
            elif ages:
                criteria_entry["AgeInUse"] = ages
            elif criteria_info.get("age"):
                criteria_entry["AgeInUse"] = criteria_info["age"]
            else:
                criteria_entry["AlwaysMet"] = None
            
            action_criteria_list.append(criteria_entry)
        
        # Add ImportFiles entries from ImportFileBuilders
        import_entries_by_scope = self._generate_import_files_entries()
        for scope, entries in import_entries_by_scope.items():
            # Determine which action group to add imports to
            if scope == "shell":
                # Add to shell action group
                shell_group_id = f"{self.mod_id}-shell-always"
                if shell_group_id not in action_groups_map:
                    action_groups_map[shell_group_id] = {
                        "id": shell_group_id,
                        "scope": "shell",
                        "criteria": "always",
                        "files_by_type": {}
                    }
                
                if "import" not in action_groups_map[shell_group_id]["files_by_type"]:
                    action_groups_map[shell_group_id]["files_by_type"]["import"] = []
                
                action_groups_map[shell_group_id]["files_by_type"]["import"].extend(entries)
            
            elif scope == "always":
                # Add to always action group
                always_group_id = f"{self.mod_id}-game-always"
                if always_group_id not in action_groups_map:
                    action_groups_map[always_group_id] = {
                        "id": always_group_id,
                        "scope": "game",
                        "criteria": "always",
                        "files_by_type": {}
                    }
                
                if "import" not in action_groups_map[always_group_id]["files_by_type"]:
                    action_groups_map[always_group_id]["files_by_type"]["import"] = []
                
                action_groups_map[always_group_id]["files_by_type"]["import"].extend(entries)
            
            else:  # "game" default
                # Add to both shell and always action groups
                shell_group_id = f"{self.mod_id}-shell-always"
                always_group_id = f"{self.mod_id}-game-always"
                
                # Shell
                if shell_group_id not in action_groups_map:
                    action_groups_map[shell_group_id] = {
                        "id": shell_group_id,
                        "scope": "shell",
                        "criteria": "always",
                        "files_by_type": {}
                    }
                
                if "import" not in action_groups_map[shell_group_id]["files_by_type"]:
                    action_groups_map[shell_group_id]["files_by_type"]["import"] = []
                
                action_groups_map[shell_group_id]["files_by_type"]["import"].extend(entries)
                
                # Always
                if always_group_id not in action_groups_map:
                    action_groups_map[always_group_id] = {
                        "id": always_group_id,
                        "scope": "game",
                        "criteria": "always",
                        "files_by_type": {}
                    }
                
                if "import" not in action_groups_map[always_group_id]["files_by_type"]:
                    action_groups_map[always_group_id]["files_by_type"]["import"] = []
                
                action_groups_map[always_group_id]["files_by_type"]["import"].extend(entries)
        
        # Create ActionGroups from categorized files
        action_groups_list = []
        type_to_action = {
            "xml": "UpdateDatabase",
            "visual-remap": "UpdateVisualRemaps",
            "icons": "UpdateIcons",
            "png": "UpdateIcons",
            "dds": "UpdateIcons",
            "localization": "UpdateText",
            "import": "ImportFiles",
            "sql": "ImportFiles",
            "lua": "ImportFiles",
            "js": "UIScripts",
        }
        
        for group_id, group_info in action_groups_map.items():
            actions = {}
            
            # Build actions for this group
            for file_type, files_in_type in group_info["files_by_type"].items():
                action_name = type_to_action.get(file_type, "ImportFiles")
                
                if action_name not in actions:
                    actions[action_name] = {"Item": []}
                
                # Ensure Item is a list
                if not isinstance(actions[action_name]["Item"], list):
                    actions[action_name]["Item"] = [actions[action_name]["Item"]]
                
                actions[action_name]["Item"].extend(files_in_type)
            
            # Only add action group if it has content
            if actions:
                action_order = [
                    "UpdateDatabase",
                    "UpdateVisualRemaps",
                    "UpdateIcons",
                    "UpdateText",
                    "ImportFiles",
                    "UIScripts",
                ]
                ordered_actions = {
                    action_name: actions[action_name]
                    for action_name in action_order
                    if action_name in actions
                }
                action_group_entry = {
                    "@id": group_id,
                    "@scope": group_info["scope"],
                    "@criteria": group_info["criteria"],
                }
                
                # Add actions
                if ordered_actions:
                    action_group_entry["Actions"] = ordered_actions
                
                action_groups_list.append(action_group_entry)
        
        # Build mod structure
        mod_dict = {
            "@id": self.id,
            "@version": self.version,
            "@xmlns": "ModInfo",
        }
        
        if properties:
            mod_dict["Properties"] = properties

        # Add References element (empty for now, can be populated later)
        mod_dict["References"] = {}

        # Add Dependencies
        if self.dependencies:
            dependency_list = []
            for dep in self.dependencies:
                if isinstance(dep, dict):
                    dependency_list.append({"@id": dep.get("id"), "@title": dep.get("title")})
                else:
                    # Handle string dependency IDs (default title)
                    dependency_list.append({"@id": str(dep), "@title": "LOC_MODULE_NAME"})
            
            if len(dependency_list) == 1:
                mod_dict["Dependencies"] = {"Mod": dependency_list[0]}
            else:
                mod_dict["Dependencies"] = {"Mod": dependency_list}
        
        # Add ActionCriteria if we have any files
        if files:
            mod_dict["ActionCriteria"] = {"Criteria": action_criteria_list}
        
        # Add ActionGroups if we have any
        if action_groups_list:
            mod_dict["ActionGroups"] = {"ActionGroup": action_groups_list}
        
        # Wrap in Mod element
        output = {"Mod": mod_dict}
        
        # Generate XML
        xml_str = xmltodict.unparse(
            output,
            pretty=True,
            indent="    ",
            full_document=True,
            encoding="UTF-8",
        )
        
        # xmltodict.unparse already includes XML declaration, so don't add it again
        return xml_str

    def _get_action_type(self, file: BaseFile) -> str:
        """
        Determine the action type for a file based on its name and path.
        
        Args:
            file: The file to categorize
            
        Returns:
            File type string (xml, png, dds, localization, visual-remap, icons, import, sql, lua, js)
        """
        filename_lower = file.name.lower()
        path_lower = file.path.lower()

        # Imports should always map to ImportFiles, regardless of extension
        if "import" in path_lower:
            return "import"
        
        # Check for JavaScript files (they need UIScripts action)
        if filename_lower.endswith(".js"):
            return "js"
        
        # Check for visual-remap files first (they need UpdateVisualRemaps action)
        if "visual-remap" in filename_lower or "visual_remap" in filename_lower:
            return "visual-remap"
        
        # Check for icon files (they need UpdateIcons action)
        if "icons.xml" in filename_lower:
            return "icons"
        
        if filename_lower.endswith(".xml"):
            # Check if it's a localization or module text file (needs UpdateText action)
            if "localization" in path_lower or "localization" in filename_lower or "moduletext" in filename_lower:
                return "localization"
            # Default XML files use UpdateDatabase
            return "xml"
        elif filename_lower.endswith(".png"):
            return "png"
        elif filename_lower.endswith(".dds"):
            return "dds"
        elif filename_lower.endswith(".sql"):
            return "sql"
        elif filename_lower.endswith(".lua"):
            return "lua"
        else:
            # Default to import for unknown types
            return "import"

    def __repr__(self) -> str:
        """String representation."""
        return f"Mod(id={self.id!r}, version={self.version!r})"
